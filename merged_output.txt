

-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====

local UIManager = require("src.ui.core.UIManager")
local UIButton = require("src.ui.elements.Button")
local Fonts = require("src.ui.fonts.init")
local DebugConsole = require("src.ui.utils.DebugConsole")
local ScrollView = require("src.ui.elements.ScrollView")
local Label = require("src.ui.elements.Label")
local ThemeManager = require("src.ui.core.ThemeManager")


local ui = require("src.ui.core.UIManager").getInstance()


function love.load()
    Fonts.load()
    love.graphics.setFont(Fonts.default)
    
    ThemeManager.setTheme("dark")
    
    -- Создаем ScrollView с явным указанием options
    local scrollView = ScrollView:new(
        100, 
        100, 
        love.graphics.getWidth() - 200, 
        love.graphics.getHeight() - 200, 
        {
            zIndex = 1,
            scrollBarSize = 10,
            scrollBarColor = {0.1, 0.5, 0.2, 0.1}
        }
    )
    

    
    local Element = require("src.ui.core.Element")
        -- Добавьте это в love.load() после создания scrollView
    
    
    
    
    
    
    
    
    
    

    

    
    
    
    for i = 1, 50 do

        
        -- Создаем Label для текста
        local label = Label:new(
            10, 15,                      -- x, y (относительно item)
            "Элемент "..i,               -- текст
            {1,1,1,1},                -- цвет (белый)
            {                            -- опции
                zIndex = 1000,
                align = "left",
                wrap = true,
                
            }
        )
        

        
        -- Добавляем элемент в scrollView
        scrollView:addChild(label)
    end
    
    ui:addElement(scrollView)
    

        -- Тестовый drop-таргет
    local dropZone = Element:new(10, 100, 200, 200, { backgroundColor = {0.3, 0.3, 0.3, 1},  
      drop = function(event) DebugConsole.log("drop в позиции:", event.x, event.y) end,
    })
    
    
    ui:addElement(dropZone)
    
    local draggableBtn = UIButton(love.graphics.getWidth() - 210, 80, 200, 50, "Перетащи меня", {
        onClick = function() DebugConsole.log("Клик!") end,
        dragstart = function(event) end,
        drag = function(event) end,
        dtagend = function(event)  end
    })
    ui:addElement(draggableBtn)
    
  
    
    
    
    

    -- Кнопка консоли
    local consoleBtn = UIButton(love.graphics.getWidth() - 210, 10, 200, 40, "КОНСОЛЬ", {
        
        onClick = function()
            DebugConsole.toggle()
        end
    })

    -- Тестовая кнопка
    local testBtn = UIButton(love.graphics.getWidth() - 210, 50, 200, 40, "scrollView", {
        
        onClick = function()
            scrollView.visible = not scrollView.visible
            scrollView.enabled = not scrollView.enabled
        end,
        zIndex = 1
    })

    ui:addElement(consoleBtn)
    ui:addElement(testBtn)

    DebugConsole.log("UI инициализирован через UIManager")
end

function love.update(dt)
    ui:update(dt)
    if DebugConsole.update then DebugConsole.update(dt) end
end

function love.draw()
    love.graphics.clear(0.1, 0.1, 0.15)
    ui:draw()
    DebugConsole.draw()
end

-- TOUCH (Android)
function love.touchpressed(id, x, y, dx, dy, pressure)
    ui:handleEvent({ type = "touchpressed", id = id, x = x, y = y, dx = dx, dy = dy, pressure = pressure })
end

function love.touchreleased(id, x, y, dx, dy, pressure)
    ui:handleEvent({ type = "touchreleased", id = id, x = x, y = y, dx = dx, dy = dy, pressure = pressure })
end

function love.touchmoved(id, x, y, dx, dy, pressure)
    ui:handleEvent({ type = "touchmoved", id = id, x = x, y = y, dx = dx, dy = dy, pressure = pressure })
end
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====

local class = require("lib.middleclass")
local EventDispatcher = require("src.ui.core.EventDispatcher")

-- Подключаем миксины
local Hierarchy = require("src.ui.core.mixins.Hierarchy")
local Visibility = require("src.ui.core.mixins.Visibility")
local Geometry = require("src.ui.core.mixins.Geometry")
local ZIndex = require("src.ui.core.mixins.ZIndex")
local Interactivity = require("src.ui.core.mixins.Interactivity")
local ContentLayout = require("src.ui.core.mixins.ContentLayout")
local Stylable = require("src.ui.core.mixins.Stylable")
local Draggable = require("src.ui.core.mixins.Draggable")
local DropTarget = require("src.ui.core.mixins.DropTarget")




local Element = class("Element")

-- Применяем миксины
Element:mixin(Hierarchy)
Element:mixin(Visibility)
Element:mixin(Geometry)
Element:mixin(ZIndex)
Element:mixin(Interactivity)
Element:mixin(ContentLayout)
Element:mixin(EventDispatcher)
Element:mixin(Stylable) -- <<< Добавляем стилизуемость
Element:mixin(Draggable)
Element:mixin(DropTarget)

function Element:initialize(x, y, w, h, options)
  
   self.options = options
  
    -- Инициализируем EventDispatcher
    EventDispatcher.initialize(self)

    -- Инициализируем миксины
    Hierarchy.initialize(self)
    Visibility.initialize(self)
    Geometry.initialize(self)
    ZIndex.initialize(self)
    Interactivity.initialize(self)
    ContentLayout.initialize(self)
    Stylable.initialize(self)
    Draggable.initialize(self)
    DropTarget.initialize(self)
    
    -- Инициализация свойств
    self.x = x or 0
    self.y = y or 0
    self.width = w or 0
    self.height = h or 0
    self.pressed = false
    self.zIndex = options and options.zIndex or 0
    
    self:setStyle(options)
    
    
  
end

-- Обработка события
-- src/ui/core/Element.lua

function Element:handleEvent(event)
    return self:dispatchEvent(event)
end

function Element:draw()
    if not self.visible then return end

    self:sortChildren()

    love.graphics.push()
    --love.graphics.translate(self.x, self.y)

    self:drawSelf()

    if self.children and #self.children > 0 then
        for _, child in ipairs(self.children) do
            child:draw()
        end
    end

    love.graphics.pop()
end

function Element:drawSelf()
    -- Рисуем фон
    
    love.graphics.setColor(self:getStyle("background_color"))
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    
end


return Element
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/EventDispatcher.lua ====

local EventDispatcher = {}

-- Вспомогательная функция для переворота массива
local function reverse(tbl)
    local reversed = {}
    for i = #tbl, 1, -1 do
        table.insert(reversed, tbl[i])
    end
    return reversed
end

function EventDispatcher:initialize()
    self._listeners = {}  -- Хранение слушателей по типам событий
end

-- Добавление слушателя с уникальным ключом
function EventDispatcher:addEventListener(eventType, callback, useCapture)
    assert(type(callback) == "function", "Callback must be a function")
    if not self._listeners[eventType] then
        self._listeners[eventType] = {
            capture = { list = {}, map = {} },
            bubble = { list = {}, map = {} }
        }
    end
    local phase = useCapture and "capture" or "bubble"
    local key = tostring(callback)
    
    -- Проверка на дубликаты через хэш-таблицу
    if not self._listeners[eventType][phase].map[key] then
        table.insert(self._listeners[eventType][phase].list, callback)
        self._listeners[eventType][phase].map[key] = true
    end
end

-- Удаление слушателя через хэш-таблицу
function EventDispatcher:removeEventListener(eventType, callback, useCapture)
    local phase = useCapture and "capture" or "bubble"
    local listeners = self._listeners[eventType]
    if not listeners then return end
    
    local phase_data = listeners[phase]
    local key = tostring(callback)
    
    if phase_data.map[key] then
        -- Поиск и удаление из списка
        for i = 1, #phase_data.list do
            if phase_data.list[i] == callback then
                table.remove(phase_data.list, i)
                phase_data.map[key] = nil
                break
            end
        end
    end
end

-- Диспетчеризация события с корректными фазами
function EventDispatcher:dispatchEvent(event)
    assert(type(event) == "table", "Event must be a table")
    assert(event.type, "Event must have a type")
    
    -- Инициализация событийных свойств
    event.target = self
    event.currentTarget = nil
    event.eventPhase = nil
    event._stopped = false
    event._immediateStopped = false
    
    -- Остановочные методы
    event.stopPropagation = function() event._stopped = true end
    event.stopImmediatePropagation = function()
        event._immediateStopped = true
        event.stopPropagation()
    end
    
    -- Сбор цепочки объектов с защитой от циклов
    local chain = {}
    local current = self
    local max_depth = 1000
    local visited = {}
    
    while current and #chain < max_depth do
        if visited[current] then break end
        visited[current] = true
        table.insert(chain, current)
        current = current.parent
    end
    
    -- Переворачиваем для фазы capture (корень → цель)
    chain = reverse(chain)
    
    -- Фаза capture (от корня к цели)
    for i = 1, #chain do
        current = chain[i]
        event.currentTarget = current
        event.eventPhase = "capture"
        
        if current:canHandleEvent(event) then
            local listeners = current._listeners[event.type]
            if listeners then
                for _, callback in ipairs(listeners.capture.list) do
                    if event._immediateStopped then break end
                    callback(event)
                end
            end
        end
        
        if event._stopped then break end
    end

    -- Фаза target (сам объект)
    event.currentTarget = self
    event.eventPhase = "target"
    
    if self:canHandleEvent(event) then
        local listeners = self._listeners[event.type]
        if listeners then
            for _, callback in ipairs(listeners.bubble.list) do
                if event._immediateStopped then break end
                callback(event)
            end
        end
    end

    -- Фаза bubbling (от цели к корню)
    if event.bubbles == nil then event.bubbles = true end
    -- Фаза bubbling (от цели к корню)
    if event.bubbles then
        -- Итерация от родителя цели к корню (исключаем сам target)
        for i = #chain-1, 1, -1 do  -- Исправление: начинаем с #chain-1 (родитель)
            current = chain[i]
            event.currentTarget = current
            event.eventPhase = "bubbling"
            
            if current:canHandleEvent(event) then
                local listeners = current._listeners[event.type]
                if listeners then
                    for _, callback in ipairs(listeners.bubble.list) do
                        if event._immediateStopped then break end
                        callback(event)
                    end
                end
            end
            
            if event._stopped then break end
        end
    end
    
    return not event._immediateStopped
end

-- Проверка условий обработки события
function EventDispatcher:canHandleEvent(event)
    -- Если свойства не указаны, считаем их true
    return (self.visible ~= false) and (self.enabled ~= false)
end

return EventDispatcher
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/EventDispatcher.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/ThemeManager.lua ====

-- src/ui/core/ThemeManager.lua

local ThemeManager = {}

-- Таблица для хранения тем
ThemeManager.themes = {
    default = {
        scrollbar_size = 10,
        scrollbar_margin = 2,
        scrollbar_color = {0.1, 0.5, 0.5, 0.5},

        background_color = {0.9, 0.9, 0.9, 1},
        bounding_box_color = {0.7, 0.6, 0.4, 1},

        touch_scroll_multiplier = 15,
        friction = 0.92,
        max_velocity = 1000,
    },
    dark = {
        scrollbar_size = 8,
        scrollbar_margin = 3,
        scrollbar_color = {0.8, 0.3, 0.3, 0.6},

        background_color = {0.2, 0.2, 0.2, 1},
        bounding_box_color = {0.5, 0.5, 0.5, 1},

        touch_scroll_multiplier = 18,
        friction = 0.95,
        max_velocity = 1200,
    }
}

-- Текущая активная тема
ThemeManager.currentTheme = "default"

-- Получить значение из текущей темы с fallback к дефолту
function ThemeManager.get(key, fallback)
    local currentTheme = ThemeManager.themes[ThemeManager.currentTheme]
    if currentTheme and currentTheme[key] ~= nil then
        return currentTheme[key]
    end
    return ThemeManager.themes.default[key] or fallback
end

-- Установить текущую тему
function ThemeManager.setTheme(name)
    if ThemeManager.themes[name] then
        ThemeManager.currentTheme = name
    else
        error("Unknown theme: " .. tostring(name))
    end
end

return ThemeManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/ThemeManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====

local UIManager = {}
UIManager.__index = UIManager



local UIManager = {}
UIManager.__index = UIManager

-- Приватная переменная для хранения единственного экземпляра
local _instance = nil

-- === getInstance ===
function UIManager.getInstance()
    if not _instance then
        _instance = UIManager:new()
    end
    return _instance
end

-- === Конструктор ===
-- В UIManager.lua

function UIManager:new()
    local obj = {
        elements = {},
        nextZIndex = 1,
        focused = nil,
        interactionTarget = nil,     -- Элемент, с которым начато взаимодействие
        interactionStarted = false,  -- Флаг начала взаимодействия
        lastTouch = { x = 0, y = 0 } -- Последнее событие касания
    }
    setmetatable(obj, self)
    return obj
end



function UIManager:addElement(element)
    if element.zIndex == nil or element.zIndex == 0 then
        element:setZIndex(self.nextZIndex)
        self.nextZIndex = self.nextZIndex + 1
    else
        -- Обновляем счётчик, если zIndex больше текущего
        if element.zIndex >= self.nextZIndex then
            self.nextZIndex = element.zIndex + 1
        end
    end

    table.insert(self.elements, element)
    self:sortElements()
end

function UIManager:removeElement(element)
    for i, el in ipairs(self.elements) do
        if el == element then
            table.remove(self.elements, i)
            self.needsSort = true
            break
        end
    end
end

function UIManager:sortElements()
    table.sort(self.elements, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self.needsSort = false
end

function UIManager:draw()
    if self.needsSort then
        self:sortElements()
    end

    for _, el in ipairs(self.elements) do
        if el.draw then el:draw() end
    end
end

function UIManager:sortByZIndex()
    table.sort(self.elements, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self.sorted = true
end

function UIManager:update(dt)
    for _, el in ipairs(self.elements) do
        if el.update then el:update(dt) end
    end
end


-- src/ui/core/UIManager.lua

function UIManager:findTargetElement(event)
    if not event.x or not event.y then return nil end

    -- Сортируем по z-index
    if self.needsSort then
        self:sortElements()
    end

    local target = nil

    -- Проверяем с конца (самый верхний)
    for i = #self.elements, 1, -1 do
        local el = self.elements[i]
        if el.visible and el.enabled and el:isInside(event.x, event.y) then
            target = self:checkChildrenForTarget(el, event)
            if target then break end
        end
    end

    return target
end


function UIManager:checkChildrenForTarget(element, event)
    -- Если есть дочерние элементы, проверяем их рекурсивно
    if element.children and #element.children > 0 then
        for i = #element.children, 1, -1 do
            local child = element.children[i]
            if child.visible and child.enabled and child:isInside(event.x, event.y) then
                local result = self:checkChildrenForTarget(child, event)
                if result then return result end
            end
        end
    end

    return element -- если среди детей никто не подошёл, возвращаем сам элемент
end

function UIManager:handleEvent(event)
    if not event.x or not event.y then
        -- События без координат (например, клавиатурные) обрабатываются как раньше
        if self.focused and self.focused:handleEvent(event) then
            return true
        end
        return false
    end

    local isPress = event.type == "mousepressed" or event.type == "touchpressed"
    local isRelease = event.type == "mousereleased" or event.type == "touchreleased"
    local isMove = event.type == "mousemoved"
    
    
    -- Если есть активное взаимодействие
    if self.interactionTarget then
        event.target = self.interactionTarget
        event.currentTarget = self.interactionTarget

        -- Для release и move продолжаем отправлять событие interactionTarget
        if isRelease or isMove then
            if self.interactionTarget.visible and self.interactionTarget.enabled then
                local result = self.interactionTarget:handleEvent(event)

                if isRelease then
                    self.interactionTarget.pressed = false
                    self.interactionTarget = nil
                    self.interactionStarted = false
                end

                return result
            else
                -- Элемент больше не активен, прекращаем взаимодействие
                self.interactionTarget = nil
                self.interactionStarted = false
                return false
            end
        end
    end

    -- Поиск нового целевого элемента только при press или move вне текущего
    local target = self:findTargetElement(event)

    if target then
        event.target = target
        event.currentTarget = target

        if isPress then
            self.interactionTarget = target
            self.interactionStarted = true
            target.pressed = true
        end

        return target:handleEvent(event)
    end

    return false
end


function UIManager:setFocus(element)
    if not element or not element.interactive then return end -- 
    
    if self.focused == element then
        return  -- уже в фокусе
    end

    -- Снимаем фокус с предыдущего элемента и его родителей
    if self.focused then
        local oldFocus = self.focused
        oldFocus.hasFocus = false
        oldFocus:dispatchEvent({ type = "focuslost" })

        -- Всплытие focuslost для родителей
        local parent = oldFocus.parent
        while parent do
            parent:dispatchEvent({ type = "focuslost", bubbles = true })
            parent = parent.parent
        end
    end

    -- Устанавливаем фокус на новый элемент
    self.focused = element
    if element then
        element.hasFocus = true
        element:dispatchEvent({ type = "focusgained" })

        -- Всплытие focusgained для родителей
        local parent = element.parent
        while parent do
            parent:dispatchEvent({ type = "focusgained", bubbles = true })
            parent = parent.parent
        end
    end
end

return UIManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ContentLayout.lua ====

local ContentLayout = {}

function ContentLayout:initialize()
    self.contentWidth = 0
    self.contentHeight = 0
    self.padding = 0
end

function ContentLayout:updateContentSize()
    self.contentWidth = 0
    self.contentHeight = 0
    for _, child in ipairs(self.children) do
        self.contentWidth = math.max(self.contentWidth, child.x + child.width)
        self.contentHeight = math.max(self.contentHeight, child.y + child.height)
    end
end

return ContentLayout
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ContentLayout.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Draggable.lua ====

local UIManager = require("src.ui.core.UIManager")
local uiManager = UIManager.getInstance()

local Draggable = {}



local Draggable = {}

function Draggable:initialize()
    self.draggable = true
    self.isDragging = false
    self.dragOffsetX = 0
    self.dragOffsetY = 0

    -- Флаги
    self.constrainDrag = true     -- Ограничивать ли перемещение
    self.dragXOnly = false        -- Только по X?
    self.dragYOnly = false        -- Только по Y?
    self.autoRaise = true         -- Автоподнятие при драге?

    -- Для временного хранения оригинального zIndex
    self.originalZIndex = nil

    self:addEventListener("touchpressed", function(e) return self:onTouchPressed(e) end)
    self:addEventListener("touchmoved", function(e) return self:onTouchMoved(e) end)
    self:addEventListener("touchreleased", function(e) return self:onTouchReleased(e) end)
    
    if self.options.drag then
      self:addEventListener("drag", function(e) return self.options.drag(e) end)
    end
    
    if self.options.dragstart then
      self:addEventListener("dragstart", function(e) return self.options.dragstart(e) end)
    end
    
    if self.options.dragend then
      self:addEventListener("dragend", function(e) return self.options.dragend(e) end)
    end
    
end

-- === Начало перетаскивания ===
function Draggable:onTouchPressed(event)
    if not self.draggable or not self:isInside(event.x, event.y) then
        return false
    end

    self.isDragging = true

    -- Сохраняем оригинальный zIndex и поднимаем элемент наверх
    if self.autoRaise then
        self.originalZIndex = self.zIndex
        self:setZIndex(9999) -- или любое значение выше других
        uiManager.needsSort = true
    end

    self.dragOffsetX = event.x - self.x
    self.dragOffsetY = event.y - self.y
    self:startDrag(event)

    return true
end

-- === findDropTarget ===
function Draggable:findDropTarget(event)
    local uiManager = UIManager.getInstance()
    local originalX, originalY = self.x, self.y

    -- Смещаем элемент немного в сторону, чтобы проверка не проходила через него
    self.x = -10000
    self.y = -10000

    local target = uiManager:findTargetElement(event)
    
    

    -- Возвращаем позицию
    self.x, self.y = originalX, originalY

    

    -- Сохраняем целевой элемент
    self._currentDropTarget = target


    return target
end

-- === Завершение перетаскивания ===
function Draggable:onTouchReleased(event)
    if not self.isDragging then return false end

    self.isDragging = false

    -- Восстанавливаем оригинальный zIndex или ставим над dropTarget
    self:findDropTarget(event)
    if self.autoRaise then
      
            if self._currentDropTarget then--and self._currentDropTarget.zIndex then
                -- Установить z над целевым элементом
                self:setZIndex(self._currentDropTarget.zIndex + 1)
            else
                -- Или вернуть исходный
                self:setZIndex(self.originalZIndex)
                
            end
            self.originalZIndex = nil
            uiManager.needsSort = true
        
    end

    self:endDrag(event)
    
    
    if not self._currentDropTarget then
              
              end
    local dropTarget = self._currentDropTarget
    self._currentDropTarget = nil
    
    
    if dropTarget then
        
        dropTarget:onDrop( event)
    end

    return true
end




-- === Перемещение при драге ===
function Draggable:onTouchMoved(event)
    if not self.isDragging then return false end
    
    local newX = self.x
    local newY = self.y

    if not self.dragXOnly then
        newX = event.x - self.dragOffsetX
    end

    if not self.dragYOnly then
        newY = event.y - self.dragOffsetY
    end

    -- Ограничение по родителю или экрану
    if self.constrainDrag then
        if self.parent then
            newX, newY = self:constrainPositionWithinParent(newX, newY)
        else
            newX, newY = self:constrainPositionWithinScreen(newX, newY)
        end
    end

    self:setPosition(newX, newY)
    self:dispatchEvent({ type = "drag", x = newX, y = newY })

    return true
end

-- === Ограничение внутри родителя ===
function Draggable:constrainPositionWithinParent(x, y)
    local parent = self.parent
    local maxX = parent.width - self.width
    local maxY = parent.height - self.height
    return math.max(0, math.min(maxX, x)), math.max(0, math.min(maxY, y))
end

-- === Ограничение по экрану ===
function Draggable:constrainPositionWithinScreen(x, y)
    local sw, sh = love.graphics.getDimensions()
    local minX, minY = 0, 0
    local maxX = sw - self.width
    local maxY = sh - self.height
    return math.max(minX, math.min(maxX, x)), math.max(minY, math.min(maxY, y))
end

-- === События начала и окончания drag ===
function Draggable:startDrag(event)
    self:dispatchEvent({ type = "dragstart", x = self.x, y = self.y })
end

function Draggable:endDrag(event)
    self:dispatchEvent({ type = "dragend", x = self.x, y = self.y })
end

-- === Изменение позиции ===
function Draggable:setPosition(x, y)
    self.x = x
    self.y = y
end

return Draggable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Draggable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/DropTarget.lua ====

local DropTarget = {}

function DropTarget:initialize()
    self.dropEnabled = true
    
    if self.options.drop then
      self:addEventListener("drop", function(e) return self.options.drop(e) end)
    end
end

function DropTarget:enableDrop()
    self.dropEnabled = true
    return self
end

function DropTarget:disableDrop()
    self.dropEnabled = false
    return self
end

-- Вызывается при drop'е другого элемента на нас
function DropTarget:onDrop(draggedElement, event)
    if not self.dropEnabled then return end
    
    self:dispatchEvent({ type = "drop", x = self.x, y = self.y  })
end

return DropTarget
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/DropTarget.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Geometry.lua ====

local Geometry = {}

function Geometry:initialize()
    self.x = 0
    self.y = 0
    self.width = 0
    self.height = 0
end

function Geometry:isInside(x, y)
    return x >= self.x and y >= self.y and x <= self.x + self.width and y <= self.y + self.height
end

function Geometry:toGlobal(x, y)
    local node = self
    while node.parent do
        x = x + node.parent.x
        y = y + node.parent.y
        node = node.parent
    end
    return x, y
end

return Geometry
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Geometry.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Hierarchy.lua ====

local Hierarchy = {}

function Hierarchy:initialize()
    self.parent = nil
    self.children = {}
end

function Hierarchy:addChild(child)
    if not child then
        require("src.ui.utils.DebugConsole").log("Child cannot be nil")
        return 
    end
    if child.parent then
        child.parent:removeChild(child)
    end
    child.parent = nil
    child.x = self.padding or 0
    child.y = (self.contentHeight or 0) + (self.padding or 0)
    table.insert(self.children, child)
    if self.updateContentSize then self:updateContentSize() end
    if self.sortChildren then self:sortChildren() end
end

function Hierarchy:removeChild(child)
    for i, c in ipairs(self.children) do
        if c == child then
            table.remove(self.children, i)
            c.parent = nil
            return
        end
    end
end

function Hierarchy:sortChildren()
    table.sort(self.children, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self._childrenSorted = true
end

function Hierarchy:getRoot()
    local node = self
    while node.parent do
        node = node.parent
    end
    return node
end

return Hierarchy
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Hierarchy.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Interactivity.lua ====

local Interactivity = {}

function Interactivity:initialize()
    self.enabled = true
    self.interactive = true
end

function Interactivity:enable()
    self.enabled = true
    return self
end

function Interactivity:disable()
    self.enabled = false
    return self
end

return Interactivity
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Interactivity.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Stylable.lua ====


local ThemeManager = require("src.ui.core.ThemeManager")

local Stylable = {}

function Stylable:initialize()
    -- Стилевые свойства, которые могут быть переопределены через options или взяты из темы
    self.style = {
        background_color = nil,
        border_color = nil,
        border_width = nil,
        padding = nil,
        margin = nil,
        font = nil,
        font_size = nil,
        corner_radius = nil,
    }

    -- Текущая тема — может изменяться глобально
    self.currentTheme = ThemeManager.currentTheme
end

-- Обновление стиля из опций
function Stylable:setStyle(options)
    if not options then return end

    for k, v in pairs(options) do
        if self.style[k] ~= nil then
            self.style[k] = v
        end
    end
end

-- Получение значения стиля с fallback к текущей теме
function Stylable:getStyle(key)
    local value = self.style[key]
    if value ~= nil then
        return value
    end

    return ThemeManager.get(key)
end

-- Установка цвета фона
function Stylable:setBackgroundColor(color)
    self.style.background_color = color
end

-- Установка цвета рамки
function Stylable:setBorderColor(color)
    self.style.border_color = color
end

-- Установка толщины рамки
function Stylable:setBorderWidth(width)
    self.style.border_width = width
end

-- Установка внутреннего отступа
function Stylable:setPadding(padding)
    self.style.padding = padding
end

-- Установка внешнего отступа
function Stylable:setMargin(margin)
    self.style.margin = margin
end

return Stylable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Stylable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Visibility.lua ====

local Visibility = {}

function Visibility:initialize()
    self.visible = true
end

function Visibility:show()
    self.visible = true
    return self
end

function Visibility:hide()
    self.visible = false
    return self
end

return Visibility
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Visibility.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ZIndex.lua ====

local ZIndex = {}

function ZIndex:initialize()
    self.zIndex = 0
end

function ZIndex:setZIndex(value)
    self.zIndex = value or 0
    if self.parent then
        self.parent:sortChildren()
    end
    return self
end

return ZIndex
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ZIndex.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Button.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local Button = class("Button", Element)

function Button:initialize(x, y, w, h, text, options)
    Element.initialize(self, x, y, w, h, options)
    self.text = text or "Button"
    self.pressed = false
    self.onClick = options and options.onClick
    self.backgroundColor = options and options.backgroundColor or {0.5, 0.5, 0.5, 1}
    self.textColor = options and options.textColor or {1, 1, 1, 1}
    
    
    

    self:addEventListener("touchpressed", function(event)
        if self:isInside(event.x, event.y) then
            self.pressed = true
        end
        return true -- ВАЖНО!
    end)
    
    self:addEventListener("touchmoved", function(event)
        if self.pressed and not self:isInside(event.x, event.y) then
            self.pressed = false
        end
        return false -- разрешаем другим обработчикам реагировать
    end)
    
    self:addEventListener("touchreleased", function(event)
        if self.pressed and self:isInside(event.x, event.y) then
            if self.onClick then self.onClick(self, event) end
        end
        self.pressed = false
        return false
    end)
end

function Button:draw()
    if not self.visible then return end

    local bgColor = self.pressed and {0.4, 0.4, 1} or {0.2, 0.2, 0.8}
    love.graphics.setColor(bgColor)
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)

    love.graphics.setColor(1, 1, 1)
    love.graphics.printf(self.text, self.x, self.y + self.height / 2 - 6, self.width, "center")

    -- Debug frame
    love.graphics.setColor(1, 1, 1, 0.5)
    love.graphics.rectangle("line", self.x, self.y, self.width, self.height)

    -- Отрисовка дочерних (если есть)
    for _, child in ipairs(self.children) do
        child:draw()
    end
end

return Button
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Button.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Label.lua ====

local Element = require("src.ui.core.Element")
local class = require("lib.middleclass")

local Label = class("Label", Element)

function Label:initialize(x, y, text, color, options)
    options = options or {}
    Element.initialize(self, x, y, 0, 0, options) -- Ширина и высота будут вычислены при установке текста
    
    self.text = text or ""
    self.font = love.graphics.getFont()
    self.color = color or {1, 1, 1, 1} -- Белый цвет по умолчанию
    self.align = options.align or "left" -- left, center, right
    self.wrap = options.wrap or false -- Перенос текста
    self.limit = options.limit -- Максимальная ширина текста
    
    
    
    -- Вычисляем размеры при инициализации
    self:updateDimensions()
end

-- Обновляет размеры label в соответствии с текстом
function Label:updateDimensions()
    if not self.font then return end
    
    if self.wrap and self.limit then
        self.width = self.limit
        local _, wrapped = self.font:getWrap(self.text, self.limit)
        self.height = #wrapped * self.font:getHeight()
    else
        self.width = self.font:getWidth(self.text)
        self.height = self.font:getHeight()
    end
end

-- Устанавливает текст и обновляет размеры
function Label:setText(text)
    self.text = text or ""
    self:updateDimensions()
    return self
end

-- Устанавливает шрифт и обновляет размеры
function Label:setFont(font)
    self.font = font or love.graphics.getFont()
    self:updateDimensions()
    return self
end

-- Устанавливает цвет текста
function Label:setColor(color)
    self.color = color or {1, 1, 1, 1}
    return self
end

-- Устанавливает выравнивание текста
function Label:setAlign(align)
    self.align = align or "left"
    return self
end

-- Отрисовка label
function Label:drawSelf()
    
    if not self.visible or not self.font or #self.text == 0 then return end
    
    
    
    local oldColor = {love.graphics.getColor()}
    love.graphics.setFont(self.font)
    love.graphics.setColor(self.color)
    
    if self.wrap and self.limit then
        love.graphics.printf(self.text, self.x, self.y, self.limit, self.align)
    else
        local x = self.x
        if self.align == "center" then
            x = x + (self.width / 2)
        elseif self.align == "right" then
            x = x + self.width
        end
        
        love.graphics.print(self.text, x, self.y, 0, 1, 1, 
                           self.align == "center" and self.width/2 or 
                           self.align == "right" and self.width or 0)
    end
    
    love.graphics.setColor(oldColor)
end

return Label
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Label.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/ScrollView.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local ScrollView = class("ScrollView", Element)



function ScrollView:initialize(x, y, w, h, options)
    options = options or {}
    Element.initialize(self, x, y, w, h, options)
    
    
    
      
      
    
    

    self.content = Element:new(10, 10, w - 10, h + 10, {})
    
    
    
    self.content.onDrop = function(target, event)
        DebugConsole.log("Элемент перетащен сюда: "..tostring(target))
    end
    
    self.content:addEventListener("touchpressed", function(e) return e.target == dropZone end)



    self.scrollY = 0
    self.maxScrollY = 0
    self.scrollX = 0
    self.maxScrollX = 10

    self.scrollBarVisible = false
    self.scrollBarSize = options.scrollBarSize or self:getStyle("scrollbar_size")
    self.scrollBarColor = options.scrollBarColor or self:getStyle("scrollbar_color")
    self.scrollBarMargin = options.scrollBarMargin or self:getStyle("scrollbar_margin")

    
    self.friction = self:getStyle("friction")
    self.maxVelocity = self:getStyle("max_velocity")

    
    -- Для тач-событий и инерции
    self.touchId = nil
    self.lastTouchY = 0
    self.lastTouchX = 0
    self.velocityY = 0
    
    
    
    -- Обработчики событий
    self:addEventListener("touchpressed", function(e) return self:onTouchPressed(e) end)
    self:addEventListener("touchreleased", function(e) return self:onTouchReleased(e) end)
    self:addEventListener("touchmoved", function(e) return self:onTouchMoved(e) end)
    
    --Element.addChild(self, self.content)
    
  
end

function ScrollView:setContentSize(w, h)
    self.content.width = w
    self.content.height = h
    self:updateScrollLimits()
end



function ScrollView:updateScrollLimits()
    local padding = self.content.padding or 0
    
    self.maxScrollX = math.max(0, (self.content.contentWidth or 0) + 2 * padding - self.width)
    self.maxScrollY = math.max(0, (self.content.contentHeight or 0) + 2 * padding - self.height)
    self.scrollY = math.max(0, math.min(self.scrollY, self.maxScrollY))
    self.scrollBarVisible = self.maxScrollY > 0
end

function ScrollView:update(dt)
    if not self.touchId and math.abs(self.velocityY) > 1 then
        local delta = self.velocityY * dt * 60
        self.scrollY = self.scrollY + delta
        self.velocityY = self.velocityY * self.friction
        
        if self.scrollY < 0 then
            self.scrollY = self.scrollY * 0.3
            self.velocityY = 0
        elseif self.scrollY > self.maxScrollY then
            self.scrollY = self.maxScrollY + (self.scrollY - self.maxScrollY) * 0.3
            self.velocityY = 0
        end
        
        self:updateScrollLimits()
    end
end



function ScrollView:onTouchPressed(event)
    if not self:isInside(event.x, event.y) then return false end
    -- Корректируем координаты события относительно контента
    local adjustedY = event.y + self.scrollY
    for _, child in ipairs(self.content.children) do
        if child:isInside(event.x, adjustedY) then
            return child:handleEvent(event)
        end
    end
    self.touchId = event.id
    self.lastTouchY = event.y
    self.velocityY = 0
    return true
end


function ScrollView:onTouchReleased(event)
    if event.id == self.touchId then
        self.touchId = nil
        return true
    end
    return false
end



function ScrollView:onTouchMoved(event)
    if event.id == self.touchId then
        -- В onTouchMoved:

        local deltaX = (self.lastTouchX - event.x)
        self.scrollX = math.max(0, math.min(self.maxScrollX, self.scrollX + deltaX))
        
        local deltaY = (self.lastTouchY - event.y)
        self.scrollY = math.max(0, math.min(self.maxScrollY, self.scrollY + deltaY))
        self.lastTouchY = event.y
        
        self.velocityY = math.max(-self.maxVelocity, math.min(self.maxVelocity, deltaY * 15))
        self.scrollY = self.scrollY + deltaY
        self:updateScrollLimits()
        return true
    end
    return false
end



function ScrollView:drawSelf()
    self.content.height = self.contentHeight

    love.graphics.setScissor(self.x, self.y, self.width, self.height)

    -- Фон
    love.graphics.setColor(self:getStyle("background_color"))
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)

    love.graphics.push()
    love.graphics.translate(self.x, self.y - self.scrollY)
    self.content:draw()
    love.graphics.pop()

    love.graphics.setScissor()

    if self.scrollBarVisible and self.maxScrollY > 0 then
        local scrollAreaHeight = self.height - self.scrollBarMargin * 2
        local scrollBarHeight = math.max(30, scrollAreaHeight * (self.height / (self.content.contentHeight or self.height)))
        local scrollBarPos = self.scrollBarMargin + (self.scrollY / self.maxScrollY) * (scrollAreaHeight - scrollBarHeight)

        love.graphics.setColor(self.scrollBarColor)
        love.graphics.rectangle("fill",
            self.x + self.width - self.scrollBarSize - self.scrollBarMargin,
            self.y + scrollBarPos,
            self.scrollBarSize,
            scrollBarHeight
        )
    end
end

function ScrollView:addChild(child)
    self.content:addChild(child)
    self.content:updateContentSize()
    self:updateScrollLimits()
end

function ScrollView:removeChild(child)
    self.content:removeChild(child)
    self:updateScrollLimits()
end

return ScrollView
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/ScrollView.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UIInputField = class("UIInputField", Element)

function UIInputField:initialize(x, y, width, height, options)
    Element.initialize(self, x, y, width, height)
    
    options = options or {}
    
    -- Свойства текста
    self.text = options.text or ""
    self.placeholder = options.placeholder or ""
    self.font = options.font or love.graphics.getFont()
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.placeholderColor = options.placeholderColor or {0.7, 0.7, 0.7, 1}
    
    -- Внешний вид
    self.backgroundColor = options.backgroundColor or {0.2, 0.2, 0.2, 1}
    self.borderColor = options.borderColor or {0.5, 0.5, 0.5, 1}
    self.focusBorderColor = options.focusBorderColor or {0.7, 0.7, 1, 1}
    self.borderWidth = options.borderWidth or 1
    self.borderRadius = options.borderRadius or 2
    self.padding = options.padding or 5
    
    -- Состояние
    self.hasFocus = false
    self.cursorPos = #self.text
    self.cursorVisible = true
    self.cursorBlinkTime = 0.5
    self.cursorTimer = 0
    self.passwordMode = options.passwordMode or false
    self.maxLength = options.maxLength or -1
    
    -- Фильтрация ввода
    self.inputFilter = options.inputFilter -- функция для фильтрации символов
    
    -- Callback
    self.onTextChanged = options.onTextChanged
    self.onEnterPressed = options.onEnterPressed
end

function UIInputField:getText()
    return self.text
end

function UIInputField:setText(text)
    self.text = text or ""
    self.cursorPos = math.min(self.cursorPos, #self.text)
    
    if self.onTextChanged then
        self.onTextChanged(self, self.text)
    end
end

function UIInputField:setPlaceholder(placeholder)
    self.placeholder = placeholder or ""
end

function UIInputField:onFocus()
    self.hasFocus = true
    self.cursorTimer = 0
    self.cursorVisible = true
end

function UIInputField:onBlur()
    self.hasFocus = false
end

-- Обработка текстового ввода
function UIInputField:textinput(text)
    if not self.hasFocus then return end
    
    -- Применяем фильтр ввода при необходимости
    if self.inputFilter and not self.inputFilter(text) then
        return
    end
    
    -- Проверяем макс. длину
    if self.maxLength > 0 and #self.text >= self.maxLength then
        return
    end
    
    -- Добавляем текст в текущую позицию курсора
    local newText = string.sub(self.text, 1, self.cursorPos) .. text .. string.sub(self.text, self.cursorPos + 1)
    self:setText(newText)
    self.cursorPos = self.cursorPos + #text
end

-- Обработка нажатия клавиш
function UIInputField:keypressed(key, scancode, isrepeat)
    if not self.hasFocus then return end
    
    if key == "backspace" then
        if self.cursorPos > 0 then
            local newText = string.sub(self.text, 1, self.cursorPos - 1) .. string.sub(self.text, self.cursorPos + 1)
            self:setText(newText)
            self.cursorPos = self.cursorPos - 1
        end
    elseif key == "delete" then
        if self.cursorPos < #self.text then
            local newText = string.sub(self.text, 1, self.cursorPos) .. string.sub(self.text, self.cursorPos + 2)
            self:setText(newText)
        end
    elseif key == "left" then
        self.cursorPos = math.max(0, self.cursorPos - 1)
    elseif key == "right" then
        self.cursorPos = math.min(#self.text, self.cursorPos + 1)
    elseif key == "home" then
        self.cursorPos = 0
    elseif key == "end" then
        self.cursorPos = #self.text
    elseif key == "return" or key == "kpenter" then
        if self.onEnterPressed then
            self.onEnterPressed(self, self.text)
        end
    end
    
    -- Сбрасываем таймер моргания курсора
    self.cursorTimer = 0
    self.cursorVisible = true
end

function UIInputField:onTouchPressed(id, x, y, dx, dy, pressure)
    if self:isInside(x, y) then
        self:focus()
        
        -- Установка позиции курсора по клику
        local clickX = x - self.x - self.padding
        local currentPos = 0
        local bestDist = math.huge
        
        for i = 0, #self.text do
            local textPart = self.passwordMode and string.rep("*", i) or string.sub(self.text, 1, i)
            local width = self.font:getWidth(textPart)
            local dist = math.abs(width - clickX)
            
            if dist < bestDist then
                bestDist = dist
                currentPos = i
            end
        end
        
        self.cursorPos = currentPos
        return true
    else
        if self.hasFocus then
            self:blur()
        end
        return false
    end
end

function UIInputField:update(dt)
    Element.update(self, dt)
    
    -- Обновление курсора
    if self.hasFocus then
        self.cursorTimer = self.cursorTimer + dt
        if self.cursorTimer >= self.cursorBlinkTime then
            self.cursorTimer = self.cursorTimer - self.cursorBlinkTime
            self.cursorVisible = not self.cursorVisible
        end
    end
end

function UIInputField:draw()
    if not self.visible then return end
    
    -- Сохраняем текущие настройки графики
    local r, g, b, a = love.graphics.getColor()
    local currentFont = love.graphics.getFont()
    
    -- Рисуем фон
    love.graphics.setColor(unpack(self.backgroundColor))
    
    if self.borderRadius > 0 and love.graphics.newCanvas then
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
    else
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Рисуем границу
    local borderColor = self.hasFocus and self.focusBorderColor or self.borderColor
    love.graphics.setColor(unpack(borderColor))
    
    if self.borderRadius > 0 and love.graphics.newCanvas then
        love.graphics.rectangle("line", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
    else
        love.graphics.rectangle("line", self.x, self.y, self.width, self.height)
    end
    
    -- Устанавливаем шрифт
    love.graphics.setFont(self.font)
    
    -- Определяем, какой текст отображать
    local displayText = self.text
    if self.passwordMode then
        displayText = string.rep("*", #self.text)
    end
    
    -- Вычисляем область отображения текста
    local textX = self.x + self.padding
    local textY = self.y + (self.height - self.font:getHeight()) / 2
    
    -- Рисуем текст или плейсхолдер
    if #self.text > 0 then
        love.graphics.setColor(unpack(self.textColor))
        love.graphics.print(displayText, textX, textY)
    else
        love.graphics.setColor(unpack(self.placeholderColor))
        love.graphics.print(self.placeholder, textX, textY)
    end
    
    -- Рисуем курсор, если поле в фокусе
    if self.hasFocus and self.cursorVisible then
        local cursorX = textX
        if #self.text > 0 and self.cursorPos > 0 then
            local textBeforeCursor = self.passwordMode and string.rep("*", self.cursorPos) or string.sub(self.text, 1, self.cursorPos)
            cursorX = textX + self.font:getWidth(textBeforeCursor)
        end
        
        love.graphics.setColor(unpack(self.textColor))
        love.graphics.rectangle("fill", cursorX, textY, 1, self.font:getHeight())
    end
    
    -- Восстанавливаем настройки графики
    love.graphics.setColor(r, g, b, a)
    love.graphics.setFont(currentFont)
    
    -- Рисуем дочерние элементы
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

function UIInputField:focus()
    Element.focus(self)
end

function UIInputField:blur()
    if self.parent and self.parent.clearFocus then
        self.parent:clearFocus()
    end
end

return UIInputField
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UILabel.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UILabel = class("UILabel", Element)

function UILabel:initialize(x, y, text, options)
    options = options or {}
    local width = options.width or 100
    local height = options.height or 30
    
    Element.initialize(self, x, y, width, height)
    
    -- Свойства
    self.text = text or ""
    self.options = options
    self.font = options.font or love.graphics.getFont()
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.backgroundColor = options.backgroundColor or {0, 0, 0, 0} -- Прозрачный по умолчанию
    self.textAlign = options.textAlign or "left" -- left, center, right
    self.verticalAlign = options.verticalAlign or "middle" -- top, middle, bottom
    self.padding = options.padding or {left = 5, top = 5, right = 5, bottom = 5}
    
    -- Если ширина не задана явно, устанавливаем по размеру текста
    if not options.width then
        self:updateDimensions()
    end
end

function UILabel:setText(text)
    self.text = text
    if not self.options.width then
        self:updateDimensions()
    end
end

function UILabel:setFont(font)
    self.font = font
    if not self.options.width then
        self:updateDimensions()
    end
end

function UILabel:updateDimensions()
    if self.font then
        self.width = self.font:getWidth(self.text) + self.padding.left + self.padding.right
        self.height = self.font:getHeight() + self.padding.top + self.padding.bottom
    end
end

function UILabel:draw()
    if not self.visible then return end
    
    -- Сохраняем текущие настройки графики
    local r, g, b, a = love.graphics.getColor()
    local currentFont = love.graphics.getFont()
    
    -- Рисуем фон, если он не полностью прозрачный
    if self.backgroundColor[4] > 0 then
        love.graphics.setColor(unpack(self.backgroundColor))
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Устанавливаем шрифт и цвет текста
    love.graphics.setFont(self.font)
    love.graphics.setColor(unpack(self.textColor))
    
    -- Вычисляем X-координату текста на основе выравнивания
    local textX = self.x + self.padding.left
    local textWidth = self.font:getWidth(self.text)
    
    if self.textAlign == "center" then
        textX = self.x + (self.width - textWidth) / 2
    elseif self.textAlign == "right" then
        textX = self.x + self.width - textWidth - self.padding.right
    end
    
    -- Вычисляем Y-координату текста на основе вертикального выравнивания
    local textY = self.y + self.padding.top
    local textHeight = self.font:getHeight()
    
    if self.verticalAlign == "middle" then
        textY = self.y + (self.height - textHeight) / 2
    elseif self.verticalAlign == "bottom" then
        textY = self.y + self.height - textHeight - self.padding.bottom
    end
    
    -- Рисуем текст
    love.graphics.print(self.text, textX, textY)
    
    -- Восстанавливаем настройки графики
    love.graphics.setColor(r, g, b, a)
    love.graphics.setFont(currentFont)
    
    -- Рисуем дочерние элементы (если есть)
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

return UILabel
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UILabel.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/fonts/init.lua ====

local Fonts = {}

function Fonts.load()
    Fonts.default = love.graphics.newFont("src/ui/fonts/font.otf", 16)
    Fonts.big = love.graphics.newFont("src/ui/fonts/font.otf", 24)
end

return Fonts
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/fonts/init.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/DebugConsole.lua ====

local DebugConsole = {
    messages = {},
    maxLines = 15,
    visible = true,
    x = 10,
    y = 10,
    width = 300,
    height = 200,
    backgroundColor = {0, 0, 0, 0.7},
    textColor = {1, 1, 1, 1},
    scrollOffset = 0,
    lastMessageTime = 0,
    autoScroll = true,
    debugTouchVisible = true,
    debugUIHierarchy = false
}

-- Логирование сообщений
function DebugConsole.log(...)
    local args = {...}
    local text = ""
    
    -- Обрабатываем все аргументы
    for i, arg in ipairs(args) do
        if i > 1 then
            text = text .. " " -- Разделитель между аргументами
        end
        text = text .. tostring(arg)
    end
    


    table.insert(DebugConsole.messages, 1, {
        text = tostring(text),
        time = love.timer.getTime()
    })
    
    -- Обрезка старых сообщений
    if #DebugConsole.messages > DebugConsole.maxLines * 3 then
        table.remove(DebugConsole.messages)
    end
    
    -- Автопрокрутка к новым сообщениям
    if DebugConsole.autoScroll then
        DebugConsole.scrollOffset = 0
    end
    
    print("[DEBUG] " .. text)
end

-- Отрисовка консоли
function DebugConsole.draw()
    if not DebugConsole.visible then return end
    
    -- Фон консоли
    love.graphics.setColor(unpack(DebugConsole.backgroundColor))
    love.graphics.rectangle("fill", DebugConsole.x, DebugConsole.y, 
                          DebugConsole.width, DebugConsole.height)
    
    -- Текст консоли
    love.graphics.setColor(unpack(DebugConsole.textColor))
    local visibleLines = math.min(DebugConsole.maxLines, #DebugConsole.messages)
    local startIndex = 1 + DebugConsole.scrollOffset
    local endIndex = math.min(startIndex + visibleLines - 1, #DebugConsole.messages)
    
    for i = startIndex, endIndex do
        local msg = DebugConsole.messages[i]
        local relIndex = i - startIndex
        love.graphics.print(msg.text, 
            DebugConsole.x + 5, 
            DebugConsole.y + 5 + relIndex * 20)
    end
    
    -- Отладочная информация (если включена)
    if DebugConsole.debugTouchVisible then
        DebugConsole.drawDebugInfo()
    end
end

-- Отладочная информация
function DebugConsole.drawDebugInfo()
    local ui = UIManager and UIManager.getInstance()
    if not ui then return end
    
    -- Последнее касание
    love.graphics.setColor(1, 0, 0, 0.5)
    love.graphics.circle("fill", ui.lastTouch.x, ui.lastTouch.y, 15)
    
    -- FPS и координаты
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("FPS: " .. love.timer.getFPS(), 10, love.graphics.getHeight() - 30)
    love.graphics.print(string.format("Touch: %d, %d", ui.lastTouch.x, ui.lastTouch.y), 
        10, love.graphics.getHeight() - 60)
end

-- Логирование иерархии UI
function DebugConsole.logUIHierarchy()
    local ui = UIManager and UIManager.getInstance()
    if not ui or not ui.root then 
        DebugConsole.log("UI Hierarchy: No root element")
        return
    end
    
    DebugConsole.log("=== UI Hierarchy ===")
    local function logElement(el, level)
        local indent = string.rep("  ", level)
        local info = string.format("%s%s [%d,%d %dx%d] %s",
            indent, tostring(el), el.x, el.y, el.width, el.height,
            el.label or "")
        DebugConsole.log(info)
        
        if el.children then
            for _, child in ipairs(el.children) do
                logElement(child, level + 1)
            end
        end
    end
    
    logElement(ui.root, 0)
end

-- Управление консолью
function DebugConsole.toggle()
    DebugConsole.visible = not DebugConsole.visible
end

function DebugConsole.toggleDebug()
    DebugConsole.debugTouchVisible = not DebugConsole.debugTouchVisible
    DebugConsole.debugUIHierarchy = not DebugConsole.debugUIHierarchy
    DebugConsole.log("Debug mode: " .. (DebugConsole.debugTouchVisible and "ON" or "OFF"))
end

-- Прокрутка консоли
function DebugConsole.scroll(direction)
    local maxOffset = math.max(0, #DebugConsole.messages - DebugConsole.maxLines)
    DebugConsole.scrollOffset = math.max(0, math.min(maxOffset, DebugConsole.scrollOffset + direction))
    DebugConsole.autoScroll = DebugConsole.scrollOffset == 0
end

-- Обработка ввода для консоли
function DebugConsole.handleInput(key)
    if key == "d" then
        DebugConsole.toggleDebug()
    elseif key == "h" then
        DebugConsole.logUIHierarchy()
    elseif key == "pageup" then
        DebugConsole.scroll(-5)
    elseif key == "pagedown" then
        DebugConsole.scroll(5)
    elseif key == "home" then
        DebugConsole.scrollOffset = 0
        DebugConsole.autoScroll = true
    elseif key == "end" then
        DebugConsole.scrollOffset = math.max(0, #DebugConsole.messages - DebugConsole.maxLines)
        DebugConsole.autoScroll = false
    end
end

-- Перемещение консоли
function DebugConsole.move(x, y)
    DebugConsole.x = math.max(0, math.min(love.graphics.getWidth() - DebugConsole.width, x))
    DebugConsole.y = math.max(0, math.min(love.graphics.getHeight() - DebugConsole.height, y))
end

return DebugConsole
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/DebugConsole.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====

