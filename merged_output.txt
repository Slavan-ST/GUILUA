

-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====

-- main.lua
local UIManager = require("src.ui.core.UIManager")
local UIButton = require("src.ui.elements.Button")
local Fonts = require("src.ui.fonts.init")
local DebugConsole = require("src.ui.utils.DebugConsole")
local ScrollView = require("src.ui.elements.ScrollView")
local UIInputField = require("src.ui.elements.UIInputField")
local Label = require("src.ui.elements.Label")
local ThemeManager = require("src.ui.core.ThemeManager")

local ui = UIManager.getInstance()

function love.load()
    -- Загрузка шрифтов
    Fonts.load()
    love.graphics.setFont(Fonts.default)

    -- Установка темы
    ThemeManager.setTheme("dark")

    -- === Создание ScrollView ===
    local scrollView = ScrollView:new({
        x = 100,
        y = 100,
        width = love.graphics.getWidth() - 200,
        height = love.graphics.getHeight() - 200,
        scrollBarSize = 10,
        zIndex = 1
    })

    for i = 1, 50 do
        local label = Label:new({
            text = "Элемент " .. i,
            align = "left",
            wrap = true,
            padding = 8
        })
        scrollView:addChild(label)
    end

    ui:addElement(scrollView)

    -- === Кнопка открытия консоли ===
    local consoleBtn = UIButton({
        x = love.graphics.getWidth() - 210,
        y = 10,
        width = 200,
        height = 40,
        text = "КОНСОЛЬ",
        onClick = function()
            DebugConsole.toggle()
        end
    })

    -- === Тестовая кнопка (показ/скрытие ScrollView) ===
    local testBtn = UIButton({
        x = love.graphics.getWidth() - 210,
        y = 50,
        width = 200,
        height = 40,
        text = "scrollView",
        zIndex = 1,
        onClick = function()
            scrollView.visible = not scrollView.visible
            scrollView.enabled = not scrollView.enabled
        end
    })

    ui:addElement(consoleBtn)
    ui:addElement(testBtn)

    -- === Поле ввода текста ===
    local input = UIInputField:new({
        x = 100,
        y = 150,
        width = 300,
        height = 40,
        placeholder = "Введите имя...",
        onTextChanged = function(field, text)
            --DebugConsole.log("Текст изменён:", text)
        end,
        onEnterPressed = function(field, text)
            DebugConsole.log("Нажат Enter:", text)
        end
    })

    ui:addElement(input)

    DebugConsole.log("UI инициализирован через UIManager")
end

function love.update(dt)
    ui:update(dt)
    if DebugConsole.update then
        DebugConsole.update(dt)
    end
end

function love.draw()
    -- love.graphics.clear(0.1, 0.1, 0.15)
    ui:draw()
    DebugConsole.draw()
end

-- === Обработчики событий ===
function love.touchpressed(id, x, y, dx, dy, pressure)
    ui:handleEvent({
        type = "touchpressed",
        id = id,
        x = x,
        y = y,
        dx = dx,
        dy = dy,
        pressure = pressure
    })
end

function love.touchreleased(id, x, y, dx, dy, pressure)
    ui:handleEvent({
        type = "touchreleased",
        id = id,
        x = x,
        y = y,
        dx = dx,
        dy = dy,
        pressure = pressure
    })
end

function love.touchmoved(id, x, y, dx, dy, pressure)
    ui:handleEvent({
        type = "touchmoved",
        id = id,
        x = x,
        y = y,
        dx = dx,
        dy = dy,
        pressure = pressure
    })
end

function love.textinput(text)
    ui:handleEvent({ type = "textinput", text = text })
end

function love.keypressed(key, scancode, isrepeat)
    ui:handleEvent({ type = "keypressed", key = key, scancode = scancode, isrepeat = isrepeat })
end
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====

-- /src/ui/core/Element.lua

local class = require("lib.middleclass")
local Drawable = require("src.ui.core.mixins.Drawable")
local EventDispatcher = require("src.ui.core.mixins.EventDispatcher")
local Hierarchy = require("src.ui.core.mixins.Hierarchy")
local Visibility = require("src.ui.core.mixins.Visibility")
local Geometry = require("src.ui.core.mixins.Geometry")
local ZIndex = require("src.ui.core.mixins.ZIndex")
local Interactivity = require("src.ui.core.mixins.Interactivity")
local ContentLayout = require("src.ui.core.mixins.ContentLayout")
local Stylable = require("src.ui.core.mixins.Stylable")
local Draggable = require("src.ui.core.mixins.Draggable")
local DropTarget = require("src.ui.core.mixins.DropTarget")
local Animation = require("src.ui.core.mixins.Animation")
local Scissorable = require("src.ui.core.mixins.Scissorable")
local Spacing = require("src.ui.core.mixins.Spacing")
local Offsetable = require("src.ui.core.mixins.Offsetable")
local InteractiveEvents = require("src.ui.core.mixins.InteractiveEvents") -- ← NEW

local Element = class("Element")

-- Применяем миксины
Element:mixin(Drawable)
Element:mixin(Hierarchy)
Element:mixin(Visibility)
Element:mixin(Geometry)
Element:mixin(ZIndex)
Element:mixin(Interactivity)
Element:mixin(ContentLayout)
Element:mixin(EventDispatcher)
Element:mixin(Stylable)
Element:mixin(Draggable)
Element:mixin(DropTarget)
Element:mixin(Animation)
Element:mixin(Scissorable)
Element:mixin(Spacing)
Element:mixin(Offsetable)
Element:mixin(InteractiveEvents) -- ← NEW

function Element:initialize(options)
   self.options = options or {}
   Drawable.initialize(self, options)
   EventDispatcher.initialize(self, self.options)

   Hierarchy.initialize(self, self.options)
   Visibility.initialize(self, self.options)
   Geometry.initialize(self, self.options)
   ZIndex.initialize(self, self.options)
   Interactivity.initialize(self, self.options)
   ContentLayout.initialize(self, self.options)
   Stylable.initialize(self, self.options)
   Draggable.initialize(self, self.options)
   DropTarget.initialize(self, self.options)
   Animation.initialize(self, self.options)
   Scissorable.initialize(self, options)
   Spacing.initialize(self, options)
   Offsetable.initialize(self, options)
end

function Element:draw()
    if not self.visible then return end
    if self.drawSelf then self:drawSelf() end
end

function Element:update(dt)
    if self.updateAnimations then self:updateAnimations(dt) end
end

return Element
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/ThemeManager.lua ====

local ThemeManager = {}

-- Таблица для хранения тем
ThemeManager.themes = {
    default = {
        scrollbar_size = 10,
        scrollbar_margin = 2,
        scrollbar_color = {0.1, 0.5, 0.5, 0.5},

        background_color = {0.9, 0.9, 0.9, 1},
        bounding_box_color = {0.7, 0.6, 0.4, 1},

        touch_scroll_multiplier = 15,
        friction = 0.92,
        max_velocity = 1000,
    },
    dark = {
        scrollbar_size = 8,
        scrollbar_margin = 3,
        scrollbar_color = {0.9, 0.9, 0.3, 0.6},

        background_color = {0.2, 0.2, 0.2, 1},
        bounding_box_color = {0.5, 0.5, 0.5, 1},

        touch_scroll_multiplier = 18,
        friction = 0.95,
        max_velocity = 1200,
    }
}

ThemeManager.currentTheme = ThemeManager.themes.dark -- по умолчанию тема dark

-- Получить значение из текущей темы с fallback к дефолту
function ThemeManager.get(key, fallback)
    local currentTheme = ThemeManager.currentTheme
    if currentTheme and currentTheme[key] ~= nil then
        
        return currentTheme[key]
    elseif ThemeManager.themes.default and ThemeManager.themes.default[key] ~= nil then
        return ThemeManager.themes.default[key]
    end

    return fallback
end

-- Установить текущую тему
function ThemeManager.setTheme(name)
    if ThemeManager.themes[name] then
        ThemeManager.currentTheme = ThemeManager.themes[name]
    else
        
    end
end

return ThemeManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/ThemeManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====

local UIManager = {}
UIManager.__index = UIManager



local UIManager = {}
UIManager.__index = UIManager

-- Приватная переменная для хранения единственного экземпляра
local _instance = nil

-- === getInstance ===
function UIManager.getInstance()
    if not _instance then
        _instance = UIManager:new()
    end
    return _instance
end

-- === Конструктор ===
-- В UIManager.lua

function UIManager:new()
    local obj = {
        elements = {},
        nextZIndex = 1,
        focused = nil,
        interactionTarget = nil,     -- Элемент, с которым начато взаимодействие
        interactionStarted = false,  -- Флаг начала взаимодействия
        lastTouch = { x = 0, y = 0 } -- Последнее событие касания
    }
    setmetatable(obj, self)
    return obj
end



function UIManager:addElement(element)
    if element.zIndex == nil or element.zIndex == 0 then
        element:setZIndex(self.nextZIndex)
        self.nextZIndex = self.nextZIndex + 1
    else
        -- Обновляем счётчик, если zIndex больше текущего
        if element.zIndex >= self.nextZIndex then
            self.nextZIndex = element.zIndex + 1
        end
    end

    table.insert(self.elements, element)
    self:sortElements()
end

function UIManager:removeElement(element)
    for i, el in ipairs(self.elements) do
        if el == element then
            table.remove(self.elements, i)
            self.needsSort = true
            break
        end
    end
end

function UIManager:sortElements()
    table.sort(self.elements, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self.needsSort = false
end

function UIManager:draw()
    if self.needsSort then
        self:sortElements()
    end

    for _, el in ipairs(self.elements) do
          if el.draw then 
            el:draw() 
            
          
          end
    end
end

function UIManager:sortByZIndex()
    table.sort(self.elements, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self.sorted = true
end

function UIManager:update(dt)
    for _, el in ipairs(self.elements) do
        if el.update then el:update(dt) end
    end
end


-- src/ui/core/UIManager.lua

function UIManager:findTargetElement(event)
    if not event.x or not event.y then return nil end

    -- Сортируем по z-index
    if self.needsSort then
        self:sortElements()
    end

    local target = nil

    -- Проверяем с конца (самый верхний)
    for i = #self.elements, 1, -1 do
        local el = self.elements[i]
        if el.visible and el.enabled and el:isInside(event.x, event.y) then
            target = self:checkChildrenForTarget(el, event)
            if target then break end
        end
    end

    return target
end


function UIManager:checkChildrenForTarget(element, event)
    -- Если есть дочерние элементы, проверяем их рекурсивно
    if element.children and #element.children > 0 then
        for i = #element.children, 1, -1 do
            local child = element.children[i]
            if child.visible and child.enabled and child:isInside(event.x, event.y) then
                local result = self:checkChildrenForTarget(child, event)
                if result then return result end
            end
        end
    end

    return element -- если среди детей никто не подошёл, возвращаем сам элемент
end

function UIManager:handleEvent(event)
    if not event.x or not event.y then
        require("src.ui.utils.DebugConsole").log("event:", event.type)
        -- События без координат (например, клавиатурные) обрабатываются как раньше
        if self.focused and self.focused:dispatchEvent(event) then
            return true
        end
        return false
    end

    local isPress = event.type == "mousepressed" or event.type == "touchpressed"
    local isRelease = event.type == "mousereleased" or event.type == "touchreleased"
    local isMove = event.type == "mousemoved"
    
    
    -- Если есть активное взаимодействие
    if self.interactionTarget then
        event.target = self.interactionTarget
        event.currentTarget = self.interactionTarget

        -- Для release и move продолжаем отправлять событие interactionTarget
        if isRelease or isMove then
            if self.interactionTarget.visible and self.interactionTarget.enabled then
                local result = self.interactionTarget:dispatchEvent(event)

                if isRelease then
                    self.interactionTarget.pressed = false
                    self.interactionTarget = nil
                    self.interactionStarted = false
                end

                return result
            else
                -- Элемент больше не активен, прекращаем взаимодействие
                self.interactionTarget = nil
                self.interactionStarted = false
                return false
            end
        end
    end

    -- Поиск нового целевого элемента только при press или move вне текущего
    local target = self:findTargetElement(event)

    if target then
        event.target = target
        event.currentTarget = target

        if isPress then
            self.interactionTarget = target
            self.interactionStarted = true
            target.pressed = true
        end

        return target:dispatchEvent(event)
    end

    return false
end


function UIManager:setFocus(element)
    if not element or not element.interactive then return end -- 
    
    if self.focused == element then
        return  -- уже в фокусе
    end

    -- Снимаем фокус с предыдущего элемента и его родителей
    if self.focused then
        local oldFocus = self.focused
        oldFocus.hasFocus = false
        oldFocus:dispatchEvent({ type = "focuslost" })

        -- Всплытие focuslost для родителей
        local parent = oldFocus.parent
        while parent do
            parent:dispatchEvent({ type = "focuslost", bubbles = true })
            parent = parent.parent
        end
    end

    -- Устанавливаем фокус на новый элемент
    self.focused = element
    if element then
        element.hasFocus = true
        element:dispatchEvent({ type = "focusgained" })

        -- Всплытие focusgained для родителей
        local parent = element.parent
        while parent do
            parent:dispatchEvent({ type = "focusgained", bubbles = true })
            parent = parent.parent
        end
    end
end

return UIManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Animation.lua ====

-- src/ui/core/mixins/Animation.lua
local Animation = {}

function Animation:initialize(options)
    -- Инициализация анимаций
    self.animations = {}
    self.animationIdCounter = 0
end

-- Запуск анимации
function Animation:animate(animationType, params, onComplete)
    self.animationIdCounter = self.animationIdCounter + 1
    local animationId = self.animationIdCounter

    
    local animation = {
        id = animationId,
        type = animationType,
        startTime = love.timer.getTime(),
        duration = params.duration or 0.3,
        from = params.from,
        to = params.to,
        easing = params.easing or "linear",
        onComplete = onComplete
    }

    table.insert(self.animations, animation)
    return animationId
end

-- Остановка анимации по ID
function Animation:stopAnimation(animationId)
    for i = #self.animations, 1, -1 do
        if self.animations[i].id == animationId then
            table.remove(self.animations, i)
            return true
        end
    end
    return false
end

-- Обновление анимаций
function Animation:updateAnimations(dt)
    local currentTime = love.timer.getTime()
    local completedAnimations = {}

    for i = #self.animations, 1, -1 do
        local anim = self.animations[i]
        local elapsedTime = currentTime - anim.startTime
        local progress = math.min(elapsedTime / anim.duration, 1)
        local easedProgress = self:applyEasing(anim.easing, progress)

        self:applyAnimationProperties(anim, easedProgress)
        
        
        if progress >= 1 then
            table.insert(completedAnimations, anim)
            table.remove(self.animations, i)
        end
    end

    for _, anim in ipairs(completedAnimations) do
        if anim.onComplete then anim.onComplete() end
    end
end

-- Easing-функции
function Animation:applyEasing(type, t)
    if type == "easeIn" then return t * t
    elseif type == "easeOut" then return 1 - (1 - t)^2
    elseif type == "easeInOut" then return t < 0.5 and 2 * t^2 or 1 - (-2 * t + 2)^2 / 2
    else return t end
end

-- Применение изменений к свойствам
function Animation:applyAnimationProperties(anim, progress)
    local value = self:lerp(anim.from, anim.to, progress)
    
    if anim.type == "scale" then
        self.scaleX = value
        self.scaleY = value
    elseif anim.type == "scaleX" then
        self.scaleX = value
    elseif anim.type == "scaleY" then
        self.scaleY = value
    elseif anim.type == "opacity" then
        self.alpha = value
    elseif anim.type == "color" then
        self:setStyle({ background_color = value })
    elseif anim.type == "position" then
        self.x = value.x
        self.y = value.y
    end
end

-- Линейная интерполяция
function Animation:lerp(from, to, progress)
    if type(from) == "number" and type(to) == "number" then
        return from + (to - from) * progress
    elseif type(from) == "table" and type(to) == "table" then
        local result = {}
        for i = 1, #from do
            result[i] = from[i] + (to[i] - from[i]) * progress
        end
        return result
    end
    return to
end

return Animation
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Animation.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ContentLayout.lua ====



-- ВНИМАНИЕ!! ПРИМЕНЯТЬ ТОЛЬКО К ЭЛЕМЕНТАМ С МИКЧИНОМ ГЕОМЕТРИИ
local ContentLayout = {}

function ContentLayout:initialize(options)
    self.contentWidth = options and options.contentWidth or 0
    self.contentHeight = options and options.contentHeight or 0
    self.padding = options and options.padding or 0
end

function ContentLayout:updateContentSize()
    self.contentWidth = 0
    self.contentHeight = 0
    for _, child in ipairs(self.children) do
        self.contentWidth = math.max(self.contentWidth, child.x + child.width)
        self.contentHeight = math.max(self.contentHeight, child.y + child.height)
    end
end

return ContentLayout
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ContentLayout.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Draggable.lua ====

local UIManager = require("src.ui.core.UIManager")
local uiManager = UIManager.getInstance()

local Draggable = {}



local Draggable = {}

function Draggable:initialize()
    self.draggable = true
    self.isDragging = false
    self.dragOffsetX = 0
    self.dragOffsetY = 0

    -- Флаги
    self.constrainDrag = true     -- Ограничивать ли перемещение
    self.dragXOnly = false        -- Только по X?
    self.dragYOnly = false        -- Только по Y?
    self.autoRaise = true         -- Автоподнятие при драге?

    -- Для временного хранения оригинального zIndex
    self.originalZIndex = nil

    self:addEventListener("touchpressed", function(e) return self:onTouchPressed(e) end)
    self:addEventListener("touchmoved", function(e) return self:onTouchMoved(e) end)
    self:addEventListener("touchreleased", function(e) return self:onTouchReleased(e) end)
    
    if self.options.drag then
      self:addEventListener("drag", function(e) return self.options.drag(e) end)
    end
    
    if self.options.dragstart then
      self:addEventListener("dragstart", function(e) return self.options.dragstart(e) end)
    end
    
    if self.options.dragend then
      self:addEventListener("dragend", function(e) return self.options.dragend(e) end)
    end
    
end

-- === Начало перетаскивания ===
function Draggable:onTouchPressed(event)
    if not self.draggable or not self:isInside(event.x, event.y) then
        return false
    end

    self.isDragging = true

    -- Сохраняем оригинальный zIndex и поднимаем элемент наверх
    if self.autoRaise then
        self.originalZIndex = self.zIndex
        self:setZIndex(9999) -- или любое значение выше других
        uiManager.needsSort = true
    end

    self.dragOffsetX = event.x - self.x
    self.dragOffsetY = event.y - self.y
    self:startDrag(event)

    return true
end

-- === findDropTarget ===
function Draggable:findDropTarget(event)
    local uiManager = UIManager.getInstance()
    local originalX, originalY = self.x, self.y

    -- Смещаем элемент немного в сторону, чтобы проверка не проходила через него
    self.x = -10000
    self.y = -10000

    local target = uiManager:findTargetElement(event)
    
    

    -- Возвращаем позицию
    self.x, self.y = originalX, originalY

    

    -- Сохраняем целевой элемент
    self._currentDropTarget = target


    return target
end

-- === Завершение перетаскивания ===
function Draggable:onTouchReleased(event)
    if not self.isDragging then return false end

    self.isDragging = false

    -- Восстанавливаем оригинальный zIndex или ставим над dropTarget
    self:findDropTarget(event)
    if self.autoRaise then
      
            if self._currentDropTarget then--and self._currentDropTarget.zIndex then
                -- Установить z над целевым элементом
                self:setZIndex(self._currentDropTarget.zIndex + 1)
            else
                -- Или вернуть исходный
                self:setZIndex(self.originalZIndex)
                
            end
            self.originalZIndex = nil
            uiManager.needsSort = true
        
    end

    self:endDrag(event)
    
    
    if not self._currentDropTarget then
              
              end
    local dropTarget = self._currentDropTarget
    self._currentDropTarget = nil
    
    
    if dropTarget then
        
        dropTarget:onDrop( event)
    end

    return true
end




-- === Перемещение при драге ===
function Draggable:onTouchMoved(event)
    if not self.isDragging then return false end
    
    local newX = self.x
    local newY = self.y

    if not self.dragXOnly then
        newX = event.x - self.dragOffsetX
    end

    if not self.dragYOnly then
        newY = event.y - self.dragOffsetY
    end

    -- Ограничение по родителю или экрану
    if self.constrainDrag then
        if self.parent then
            newX, newY = self:constrainPositionWithinParent(newX, newY)
        else
            newX, newY = self:constrainPositionWithinScreen(newX, newY)
        end
    end

    self:setPosition(newX, newY)
    self:dispatchEvent({ type = "drag", x = newX, y = newY })

    return true
end

-- === Ограничение внутри родителя ===
function Draggable:constrainPositionWithinParent(x, y)
    local parent = self.parent
    local maxX = parent.width - self.width
    local maxY = parent.height - self.height
    return math.max(0, math.min(maxX, x)), math.max(0, math.min(maxY, y))
end

-- === Ограничение по экрану ===
function Draggable:constrainPositionWithinScreen(x, y)
    local sw, sh = love.graphics.getDimensions()
    local minX, minY = 0, 0
    local maxX = sw - self.width
    local maxY = sh - self.height
    return math.max(minX, math.min(maxX, x)), math.max(minY, math.min(maxY, y))
end

-- === События начала и окончания drag ===
function Draggable:startDrag(event)
    self:dispatchEvent({ type = "dragstart", x = self.x, y = self.y })
end

function Draggable:endDrag(event)
    self:dispatchEvent({ type = "dragend", x = self.x, y = self.y })
end

-- === Изменение позиции ===
function Draggable:setPosition(x, y)
    self.x = x
    self.y = y
end

return Draggable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Draggable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Drawable.lua ====

local Drawable = {}

function Drawable:initialize(options)
    self.zIndex = options and options.zIndex or 0
end

function Drawable:drawSelf()
    if not self.visible then return end

    love.graphics.push() -- <-- Сначала push()

    -- 1. Устанавливаем scissor (обрезку), если включена
    self:applyScissor()

    -- 2. Рисуем фон элемента
    love.graphics.setColor(self:getStyle("background_color"))
    love.graphics.rectangle(
        "fill",
        self.x + self:getMarginLeft(),
        self.y + self:getMarginTop(),
        self.width - self:getMarginX(),
        self.height - self:getMarginY()
    )

    -- 3. Рисуем рамку, если задана
    local borderColor = self:getStyle("border_color")
    local borderWidth = self:getStyle("border_width") or 0

    if borderColor and borderWidth > 0 then
        love.graphics.setColor(borderColor)
        love.graphics.setLineWidth(borderWidth)
        love.graphics.rectangle(
            "line",
            self.x + self:getMarginLeft() + borderWidth / 2,
            self.y + self:getMarginTop() + borderWidth / 2,
            self.width - self:getMarginX() - borderWidth,
            self.height - self:getMarginY() - borderWidth
        )
    end

    -- 4. Переводим координаты на offset (например, для скролла)
    love.graphics.translate(
        self:getOffsetX(),
        self:getOffsetY()
    )

    -- 5. Рисуем содержимое внутри padding'ов
    love.graphics.translate(
        self.x + self:getMarginLeft() + self:getPaddingLeft(),
        self.y + self:getMarginTop() + self:getPaddingTop()
    )
    
    -- Вызываем drawContent(), если определён (может быть у контейнеров/прокрутки)
    if self.drawContent then
        self:drawContent()
    end

     love.graphics.pop()-- <-- pop() закрывает весь блок
    self:clearScissor() -- <-- восстанавливаем старый scissor вне push/pop
end
function Drawable:drawContent()
  if self.children and #self.children > 0 then
                  for _, child in ipairs(self.children) do
                      
                      child:draw()
                      
                  end
            end
end

return Drawable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Drawable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/DropTarget.lua ====

-- ВНИМАНИЕ!! ПРИМЕНЯТЬ ТОЛЬКО К ЭЛЕМЕНТАМ С МИКЧИНОМ ГЕОМЕТРИИ

local DropTarget = {}

function DropTarget:initialize()
    self.dropEnabled = true
    
    if self.options.drop then
      self:addEventListener("drop", function(e) return self.options.drop(e) end)
    end
end

function DropTarget:enableDrop()
    self.dropEnabled = true
    return self
end

function DropTarget:disableDrop()
    self.dropEnabled = false
    return self
end

-- Вызывается при drop'е другого элемента на нас
function DropTarget:onDrop(draggedElement, event)
    if not self.dropEnabled then return end
    
    self:dispatchEvent({ type = "drop", x = self.x, y = self.y  })
end

return DropTarget
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/DropTarget.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/EventDispatcher.lua ====

local EventDispatcher = {}

-- Вспомогательная функция для переворота массива
local function reverse(tbl)
    local reversed = {}
    for i = #tbl, 1, -1 do
        table.insert(reversed, tbl[i])
    end
    return reversed
end

function EventDispatcher:initialize()
    self._listeners = {}  -- Хранение слушателей по типам событий
end

-- Добавление слушателя с уникальным ключом
function EventDispatcher:addEventListener(eventType, callback, useCapture)
    assert(type(callback) == "function", "Callback must be a function")
    if not self._listeners[eventType] then
        self._listeners[eventType] = {
            capture = { list = {}, map = {} },
            bubble = { list = {}, map = {} }
        }
    end
    local phase = useCapture and "capture" or "bubble"
    local key = tostring(callback)
    
    -- Проверка на дубликаты через хэш-таблицу
    if not self._listeners[eventType][phase].map[key] then
        table.insert(self._listeners[eventType][phase].list, callback)
        self._listeners[eventType][phase].map[key] = true
    end
end

-- Удаление слушателя через хэш-таблицу
function EventDispatcher:removeEventListener(eventType, callback, useCapture)
    local phase = useCapture and "capture" or "bubble"
    local listeners = self._listeners[eventType]
    if not listeners then return end
    
    local phase_data = listeners[phase]
    local key = tostring(callback)
    
    if phase_data.map[key] then
        -- Поиск и удаление из списка
        for i = 1, #phase_data.list do
            if phase_data.list[i] == callback then
                table.remove(phase_data.list, i)
                phase_data.map[key] = nil
                break
            end
        end
    end
end

-- Диспетчеризация события с корректными фазами
function EventDispatcher:dispatchEvent(event)
    assert(type(event) == "table", "Event must be a table")
    assert(event.type, "Event must have a type")
    
    -- Инициализация событийных свойств
    event.target = self
    event.currentTarget = nil
    event.eventPhase = nil
    event._stopped = false
    event._immediateStopped = false
    
    -- Остановочные методы
    event.stopPropagation = function() event._stopped = true end
    event.stopImmediatePropagation = function()
        event._immediateStopped = true
        event.stopPropagation()
    end
    
    -- Сбор цепочки объектов с защитой от циклов
    local chain = {}
    local current = self
    local max_depth = 1000
    local visited = {}
    
    while current and #chain < max_depth do
        if visited[current] then break end
        visited[current] = true
        table.insert(chain, current)
        current = current.parent
    end
    
    -- Переворачиваем для фазы capture (корень → цель)
    chain = reverse(chain)
    
    -- Фаза capture (от корня к цели)
    for i = 1, #chain do
        current = chain[i]
        event.currentTarget = current
        event.eventPhase = "capture"
        
        if current:canHandleEvent(event) then
            local listeners = current._listeners[event.type]
            if listeners then
                for _, callback in ipairs(listeners.capture.list) do
                    if event._immediateStopped then break end
                    callback(event)
                end
            end
        end
        
        if event._stopped then break end
    end

    -- Фаза target (сам объект)
    event.currentTarget = self
    event.eventPhase = "target"
    
    if self:canHandleEvent(event) then
        local listeners = self._listeners[event.type]
        if listeners then
            for _, callback in ipairs(listeners.bubble.list) do
                if event._immediateStopped then break end
                callback(event)
            end
        end
    end

    -- Фаза bubbling (от цели к корню)
    if event.bubbles == nil then event.bubbles = true end
    -- Фаза bubbling (от цели к корню)
    if event.bubbles then
        -- Итерация от родителя цели к корню (исключаем сам target)
        for i = #chain-1, 1, -1 do  -- Исправление: начинаем с #chain-1 (родитель)
            current = chain[i]
            event.currentTarget = current
            event.eventPhase = "bubbling"
            
            if current:canHandleEvent(event) then
                local listeners = current._listeners[event.type]
                if listeners then
                    for _, callback in ipairs(listeners.bubble.list) do
                        if event._immediateStopped then break end
                        callback(event)
                    end
                end
            end
            
            if event._stopped then break end
        end
    end
    
    return not event._immediateStopped
end

-- Проверка условий обработки события
function EventDispatcher:canHandleEvent(event)
    -- Если свойства не указаны, считаем их true
    return (self.visible ~= false) and (self.enabled ~= false)
end

return EventDispatcher
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/EventDispatcher.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Focus.lua ====

local Focus = {}
local  UIManager = require("src.ui.core.UIManager")
local ui = UIManager.getInstance()


function Focus:initialize(options)
    self.hasFocus = false

    -- Привязываем обработчики событий, если они нужны
    if options and options.focusHandlers then
        self:on("focusgained", options.focusHandlers.onFocusGained)
        self:on("focuslost",  options.focusHandlers.onFocusLost)
    end
end

-- Устанавливает фокус на этот элемент
function Focus:focus()
    
    if self.interactive ~= false then
        ui:setFocus(self)
    end
    return self
end

-- Проверяет, находится ли элемент в фокусе
function Focus:isFocused()
    return self.hasFocus == true
end

return Focus
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Focus.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Geometry.lua ====

local Geometry = {}

function Geometry:initialize(options)
    self.x = options and options.x or 0
    self.y = options and options.y or 0
    self.width = options and options.width or 0
    self.height = options and options.height or 0
end

function Geometry:isInside(x, y)
    return x >= self.x and y >= self.y and x <= self.x + self.width and y <= self.y + self.height
end


return Geometry
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Geometry.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Hierarchy.lua ====

local Hierarchy = {}

function Hierarchy:initialize(options)
    self.parent = options and options.parent or nil
    self.children = options and options.contentWidth or {}
end

function Hierarchy:addChild(child)
    if not child then
        return 
    end
    if child.parent then
        child.parent:removeChild(child)
    end
    child.parent = nil
    
    table.insert(self.children, child)
    self:sortChildren()
end

function Hierarchy:removeChild(child)
    for i, c in ipairs(self.children) do
        if c == child then
            table.remove(self.children, i)
            c.parent = nil
            return
        end
    end
end

function Hierarchy:sortChildren()
    table.sort(self.children, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self._childrenSorted = true
end

function Hierarchy:getRoot()
    local node = self
    while node.parent do
        node = node.parent
    end
    return node
end

function Hierarchy:toGlobal(x, y)
    if not self.parent then return self.x, self.y end
    local node = self
    while node.parent do
        x = x + node.parent.x
        y = y + node.parent.y
        node = node.parent
    end
    return x, y
end

return Hierarchy
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Hierarchy.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/InteractiveEvents.lua ====

-- /src/ui/core/mixins/InteractiveEvents.lua

local InteractiveEvents = {}

function InteractiveEvents:initialize()
    -- Подписываемся на события через EventDispatcher
    self:addEventListener("touchpressed", function(e) return self:onTouchPressed(e) end)
    self:addEventListener("touchreleased", function(e) return self:onTouchReleased(e) end)
    self:addEventListener("touchmoved", function(e) return self:onTouchMoved(e) end)
    self:addEventListener("keypressed", function(e) return self:onKeyPressed(e) end)
    self:addEventListener("textinput", function(e) return self:onTextInput(e) end)
end

-- Базовая обработка нажатия
function InteractiveEvents:onTouchPressed(event)
    if not self.interactive or not self.enabled then return false end
    self.pressed = true
    return true
end

-- Обработка отпускания
function InteractiveEvents:onTouchReleased(event)
    if self.pressed and self:isInside(event.x, event.y) then
        self:dispatchEvent({ type = "click" })
    end
    self.pressed = false
    return true
end

-- Перемещение пальца
function InteractiveEvents:onTouchMoved(event)
    if self.pressed and not self:isInside(event.x, event.y) then
        self.pressed = false
    end
    return false
end

-- Нажатие клавиши (например Enter)
function InteractiveEvents:onKeyPressed(event)
    return false
end

-- Ввод текста (например, при использовании UIInputField)
function InteractiveEvents:onTextInput(text)
    return false
end

return InteractiveEvents
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/InteractiveEvents.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Interactivity.lua ====

local Interactivity = {}

function Interactivity:initialize()
    self.enabled = true
    self.interactive = true
end

function Interactivity:enable()
    self.enabled = true
    return self
end

function Interactivity:disable()
    self.enabled = false
    return self
end

return Interactivity
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Interactivity.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Offsetable.lua ====

-- src/ui/core/mixins/Offsetable.lua
local Offsetable = {}

function Offsetable:initialize(options)
    self.offsetX = options and options.offsetX or 0
    self.offsetY = options and options.offsetY or 0
end

function Offsetable:setOffset(x, y)
    self.offsetX = x or self.offsetX
    self.offsetY = y or self.offsetY
end

function Offsetable:getOffsetX() return self.offsetX end
function Offsetable:getOffsetY() return self.offsetY end

return Offsetable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Offsetable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Scissorable.lua ====

-- src/ui/core/mixins/Scissorable.lua
local Scissorable = {}

function Scissorable:initialize(options)
    self.scissorEnabled = options and options.scissor or false
    self._previousScissor = nil -- Для хранения старого scissor
end

function Scissorable:enableScissor(enable)
    self.scissorEnabled = enable ~= false
end

function Scissorable:applyScissor()
    if self.scissorEnabled then
        -- Сохраняем текущую область обрезки
        local x, y, w, h = love.graphics.getScissor()
        self._previousScissor = x and {x, y, w, h} or nil
        
        -- Устанавливаем новый scissor
        love.graphics.setScissor(
            self.x + self:getMarginLeft(),
            self.y + self:getMarginTop(),
            self.width - self:getMarginX(),
            self.height - self:getMarginY()
        )
    end
end

function Scissorable:clearScissor()
    if self.scissorEnabled then
    -- Восстанавливаем предыдущую область обрезки
    if self._previousScissor and #self._previousScissor == 4 then
        love.graphics.setScissor(
            self._previousScissor[1],
            self._previousScissor[2],
            self._previousScissor[3],
            self._previousScissor[4]
        )
    else
        love.graphics.setScissor() -- Отключаем scissor
    end
    self._previousScissor = nil
end
end
return Scissorable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Scissorable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Spacing.lua ====

-- src/ui/core/mixins/Spacing.lua
local Spacing = {}

function Spacing:initialize(options)
    self.paddingLeft   = options and options.paddingLeft or 0
    self.paddingRight  = options and options.paddingRight or 0
    self.paddingTop    = options and options.paddingTop or 0
    self.paddingBottom = options and options.paddingBottom or 0

    self.marginLeft   = options and options.marginLeft or 0
    self.marginRight  = options and options.marginRight or 0
    self.marginTop    = options and options.marginTop or 0
    self.marginBottom = options and options.marginBottom or 0
end

function Spacing:getPaddingX() return self.paddingLeft + self.paddingRight end
function Spacing:getPaddingY() return self.paddingTop + self.paddingBottom end
function Spacing:getMarginX() return self.marginLeft + self.marginRight end
function Spacing:getMarginY() return self.marginTop + self.marginBottom end

function Spacing:setPadding(left, right, top, bottom)
    self.paddingLeft = left or self.paddingLeft
    self.paddingRight = right or self.paddingRight
    self.paddingTop = top or self.paddingTop
    self.paddingBottom = bottom or self.paddingBottom
end

function Spacing:setMargin(left, right, top, bottom)
    self.marginLeft = left or self.marginLeft
    self.marginRight = right or self.marginRight
    self.marginTop = top or self.marginTop
    self.marginBottom = bottom or self.marginBottom
end

-- src/ui/core/mixins/Spacing.lua

function Spacing:getMarginLeft()   return self.marginLeft or 0 end
function Spacing:getMarginRight()  return self.marginRight or 0 end
function Spacing:getMarginTop()    return self.marginTop or 0 end
function Spacing:getMarginBottom() return self.marginBottom or 0 end
function Spacing:getMarginX() return self:getMarginLeft() + self:getMarginRight() end
function Spacing:getMarginY() return self:getMarginTop() + self:getMarginBottom() end

function Spacing:getPaddingLeft()   return self.paddingLeft or 0 end
function Spacing:getPaddingRight()  return self.paddingRight or 0 end
function Spacing:getPaddingTop()    return self.paddingTop or 0 end
function Spacing:getPaddingBottom() return self.paddingBottom or 0 end
function Spacing:getPaddingX() return self:getPaddingLeft() + self:getPaddingRight() end
function Spacing:getPaddingY() return self:getPaddingTop() + self:getPaddingBottom() end

return Spacing
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Spacing.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Stylable.lua ====


local ThemeManager = require("src.ui.core.ThemeManager")

local Stylable = {}

function Stylable:initialize(options)
    -- Стилевые свойства, которые могут быть переопределены через options или взяты из темы
    self.style = {
        background_color = nil,
        border_color = nil,
        border_width = nil,
        padding = nil,
        margin = nil,
        font = nil,
        font_size = nil,
        corner_radius = nil,
    }

    -- Текущая тема — может изменяться глобально
    self.currentTheme = ThemeManager.currentTheme
end

-- Обновление стиля из опций
-- Обновление стиля из опций
function Stylable:setStyle(options)
    if not options then return end
    for k, v in pairs(options) do
        self.style[k] = v  -- Просто устанавливаем все ключи из options
    end
end

-- Получение значения стиля с fallback к текущей теме
function Stylable:getStyle(key)
    return ThemeManager.get(key)
end


return Stylable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Stylable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/TextEditable.lua ====

-- /src/ui/core/mixins/TextEditable.lua
local UIManager = require("src.ui.core.UIManager")
-- В начале файла:
local utf8 = require("src.ui.utils.UTF8Utils") -- загружаем наш модуль

local TextEditable = {}

function TextEditable:initialize(options)
    -- === Свойства ввода текста ===
    self.text = options.text or ""
    self.placeholder = options.placeholder or ""
    self.passwordMode = options.passwordMode or false
    self.maxLength = options.maxLength or -1

    -- === Цвета и стиль ===
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.placeholderColor = options.placeholderColor or {0.7, 0.7, 0.7, 1}

    -- === Курсор ===
    self.hasFocus = false
    self.cursorPos = utf8.len(self.text) -- Используем utf8
    self.cursorVisible = true
    self.cursorBlinkTime = 0.5
    self.cursorTimer = 0

    -- === Callbacks ===
    self.onTextChanged = options.onTextChanged
    self.onEnterPressed = options.onEnterPressed

    -- === Фильтры ===
    self.inputFilter = options.inputFilter

    -- Подписываемся на нужные события через InteractiveEvents
    self:addEventListener("textinput", function(text) return self:textinput(text) end)
    self:addEventListener("keypressed", function(e) return self:keypressed(e.key) end)
    self:addEventListener("focusgained", function() self:onFocus() end)
    self:addEventListener("focuslost", function() self:onBlur() end)

    -- Регистрируем методы для базового поведения (если ещё не добавлены)
    if not self.onTouchPressed then
        self:addEventListener("touchpressed", function(e) return self:onTouchPressed(e) end)
    end
end

-- === Обновление состояния при фокусе ===
function TextEditable:onFocus()
    self.hasFocus = true
    self.cursorTimer = 0
    self.cursorVisible = true
end

function TextEditable:onBlur()
    self.hasFocus = false
end

-- === Обработка текстового ввода ===
function TextEditable:textinput(event)
    if not self.hasFocus then return end

    local text
    if type(event) == "string" then
        text = event
    elseif type(event) == "table" and type(event.text) == "string" then
        text = event.text
    else
        return
    end

    if not text or #text == 0 then
        return
    end

    if self.inputFilter and not self.inputFilter(text) then
        return
    end

    if self.maxLength > 0 and utf8.len(self.text) + utf8.len(text) > self.maxLength then
        return
    end

    local before = utf8.sub(self.text, 1, self.cursorPos)
    local after = utf8.sub(self.text, self.cursorPos + 1)
    local newText = before .. text .. after

    self:setText(newText)
    self.cursorPos = self.cursorPos + utf8.len(text)
end

-- === Обработка клавиш (backspace, delete, стрелки и т.д.) ===
function TextEditable:keypressed(key)
    if not self.hasFocus then return end

    if key == "backspace" then
        if self.cursorPos > 0 then
            local before = utf8.sub(self.text, 1, self.cursorPos - 1)
            local after = utf8.sub(self.text, self.cursorPos + 1)
            self:setText(before .. after)
            self.cursorPos = math.max(0, self.cursorPos - 1)
        end
    elseif key == "delete" then
        if self.cursorPos < utf8.len(self.text) then
            local before = utf8.sub(self.text, 1, self.cursorPos)
            local after = utf8.sub(self.text, self.cursorPos + 2)
            self:setText(before .. after)
        end
    elseif key == "left" then
        self.cursorPos = math.max(0, self.cursorPos - 1)
    elseif key == "right" then
        self.cursorPos = math.min(utf8.len(self.text), self.cursorPos + 1)
    elseif key == "home" then
        self.cursorPos = 0
    elseif key == "end" then
        self.cursorPos = utf8.len(self.text)
    elseif key == "return" or key == "kpenter" then
        if self.onEnterPressed then
            self.onEnterPressed(self, self.text)
        end
        return
    else
        return
    end

    self.cursorTimer = 0
    self.cursorVisible = true
end

-- === Нажатие по полю — запрос фокуса ===
function TextEditable:onTouchPressed(event)
    if not self:isInside(event.x, event.y) then return false end

    self:requestFocus()
    love.keyboard.setTextInput(true)

    -- Вычисляем позицию курсора по координатам X
    local font = love.graphics.getFont()
    local paddingLeft = self:getPaddingLeft()
    local textTop = (self.height - font:getHeight()) / 2
    local textBottom = textTop + font:getHeight()

    -- Проверяем, находится ли Y внутри области текста
    if  event.y >= self.y + textTop and 
        event.y <= self.y + textBottom then
        require("src.ui.utils.DebugConsole").log("displayText", utf8.len(self.text))
        local relativeX = event.x - paddingLeft
        self.cursorPos = self:getCursorPositionFromX(relativeX)
    else
        self.cursorPos = 0
    end

    self.cursorTimer = 0
    self.cursorVisible = true

    return true
end

-- === Установка нового текста ===
function TextEditable:setText(text)
    self.text = text or ""
    self.cursorPos = math.min(self.cursorPos, utf8.len(self.text))
    if self.onTextChanged then
        self.onTextChanged(self, self.text)
    end
    return self
end

-- === Получение текущего текста ===
function TextEditable:getText()
    return self.text
end

-- === Обновление курсора ===
function TextEditable:update(dt)
    if self.hasFocus then
        self.cursorTimer = self.cursorTimer + dt
        if self.cursorTimer >= self.cursorBlinkTime then
            self.cursorTimer = self.cursorTimer - self.cursorBlinkTime
            self.cursorVisible = not self.cursorVisible
        end
    end
end

-- === Отрисовка текста и курсора ===
function TextEditable:drawTextContent()
    local font = love.graphics.getFont()
    local displayText = self.text
    if self.passwordMode then
        displayText = string.rep("*", utf8.len(self.text)) -- Используем utf8.len
    end

    local textColor = self.textColor
    local x = self:getPaddingLeft()
    local y = (self.height - font:getHeight()) / 2

    love.graphics.setFont(font)
    love.graphics.setColor(textColor)

    if utf8.len(self.text) == 0 and self.placeholder and self.placeholder ~= "" then
        love.graphics.setColor(self.placeholderColor)
        love.graphics.print(self.placeholder, x, y)
    else
        love.graphics.setColor(textColor)
        love.graphics.print(displayText, x, y)
    end

    -- Рисуем курсор
    if self.hasFocus and self.cursorVisible then
        local cursorX = x
        if utf8.len(displayText) > 0 and self.cursorPos > 0 then
            local part = utf8.sub(displayText, 1, self.cursorPos)
            cursorX = x + font:getWidth(part)
        end
        love.graphics.setColor(textColor)
        love.graphics.rectangle("fill", cursorX, y, 1, font:getHeight())
    end
end

-- === Запрос фокуса ===
function TextEditable:requestFocus()
    local ui = UIManager.getInstance()
    ui:setFocus(self)
    return true
end

function TextEditable:getCursorPositionFromX(clickX)
    clickX = clickX - self.x
    local font = love.graphics.getFont()
    local displayText = self.text
    if self.passwordMode then
        displayText = string.rep("*", utf8.len(self.text))
    end

    local paddingLeft = self:getPaddingLeft()
    local x = paddingLeft
    local cursorPos = 0

    
    -- Если текста нет, то всегда позиция 0
    if utf8.len(displayText) == 0 then
        return 0
    end

    -- Перебираем каждый символ и сравниваем с позицией клика
    for i = 1, utf8.len(displayText) do
        local char = utf8.sub(displayText, i, i)
        local charWidth = font:getWidth(char)

        -- Проверяем, попадает ли клик между предыдущим и текущим символом
        local midPoint = x + charWidth / 2
        if clickX < midPoint and  clickX > (x - charWidth / 2) then
            return cursorPos
        end

        x = x + charWidth
        cursorPos = i
    end

    -- Если клик правее всех символов — ставим в конец
    return cursorPos
end

return TextEditable
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/TextEditable.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Visibility.lua ====

local Visibility = {}

function Visibility:initialize(options)
    self.visible = options and options.visible or true
end

function Visibility:show()
    self.visible = true
    return self
end

function Visibility:hide()
    self.visible = false
    return self
end

return Visibility
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Visibility.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ZIndex.lua ====

local ZIndex = {}

function ZIndex:initialize(options)
    self.zIndex = options and options.zIndex or 0
end

function ZIndex:setZIndex(value)
    self.zIndex = value or 0
    return self
end

return ZIndex
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ZIndex.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Button.lua ====

-- /src/ui/elements/Button.lua

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")
local Button = class("Button", Element)

function Button:initialize(options)
    Element.initialize(self, options)

    -- === Текст кнопки ===
    self.text = options and options.text or "Button"
    self.pressed = false
    self.onClick = options and options.onClick

    -- === Стили ===
    self:setStyle({
        background_color = options and options.backgroundColor or {0.5, 0.5, 0.5, 1},
        border_color     = options and options.borderColor or nil,
        border_width     = options and options.borderWidth or 0,
        text_color       = options and options.textColor or {1, 1, 1, 1}
    })

    -- === Отступы ===
    if options then
        if options.padding then
            self:setPadding(options.padding)
        else
            self:setPadding(
                options.paddingLeft or self.paddingLeft,
                options.paddingRight or self.paddingRight,
                options.paddingTop or self.paddingTop,
                options.paddingBottom or self.paddingBottom
            )
        end
        if options.margin then
            self:setMargin(options.margin)
        else
            self:setMargin(
                options.marginLeft or self.marginLeft,
                options.marginRight or self.marginRight,
                options.marginTop or self.marginTop,
                options.marginBottom or self.marginBottom
            )
        end
        if options.scissor ~= nil then
            self:enableScissor(options.scissor)
        else
            self:enableScissor(false)
        end
    end

    -- === Добавляем обработчик клика ===
    self:addEventListener("click", function()
        if self.onClick then
            self.onClick(self)
        end
    end)
end

-- === Рисование контента кнопки ===
function Button:drawContent()
    love.graphics.setColor(unpack(self:getStyle("text_color") or {1,1,1,1}))
    love.graphics.printf(
        self.text,
        0,
        self.height / 2 - 6,
        self.width,
        "center"
    )
end

return Button
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Button.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Label.lua ====

-- /src/ui/elements/Label.lua

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")
local Label = class("Label", Element)

function Label:initialize(options)
    options = options or {}
    Element.initialize(self, options)

    -- === Текст ===
    self.text = options.text or ""
    self.font = options.font or love.graphics.getFont()
    self.align = options.align or "left" -- left, center, right
    self.verticalAlign = options.verticalAlign or "middle" -- top, middle, bottom
    self.wrap = options.wrap or false     -- Перенос текста
    self.limit = options.limit            -- Ширина для переноса

    -- === Цвет текста через стиль ===
    self.textColor = options.color or {1, 1, 1, 1}

    -- === Стили ===
    if options.backgroundColor then
        self:setStyle({ background_color = options.backgroundColor })
    end

    -- === Автоматическое обновление размеров ===
    self:autoSize()

    -- === Обработчики событий ===
    if options.onClick then
        self:addEventListener("click", function(e) return options.onClick(self, e) end)
    end
end

-- === Автоматически вычисляет ширину и высоту под текст ===
function Label:autoSize()
    if not self.font then return end

    if self.wrap and self.limit then
        self.contentWidth = self.limit
        local _, wrapped = self.font:getWrap(self.text, self.limit)
        self.contentHeight = #wrapped * self.font:getHeight()
    else
        self.contentWidth = self.font:getWidth(self.text)
        self.contentHeight = self.font:getHeight()
    end

    -- Если не заданы width/height явно — используем contentWidth/contentHeight
    if not self._widthSetExplicitly then
        self.width = self.contentWidth + self:getPaddingX()
    end
    if not self._heightSetExplicitly then
        self.height = self.contentHeight + self:getPaddingY()
    end
end

-- === Обновляем размеры при изменении текста ===
function Label:setText(text)
    self.text = text or ""
    self:autoSize()
    return self
end

-- === Устанавливаем шрифт ===
function Label:setFont(font)
    self.font = font or love.graphics.getFont()
    self:autoSize()
    return self
end

-- === Устанавливаем выравнивание ===
function Label:setAlign(align)
    self.align = align or "left"
    return self
end

-- === drawContent — рисует внутри padding'а элемента ===
function Label:drawContent(width, height)
    if #self.text == 0 or not self.font then return end

    local color = self.textColor or self:getStyle("text_color") or {1, 1, 1, 1}
    love.graphics.setFont(self.font)
    love.graphics.setColor(color)

    local x = self:getPaddingLeft()
    local y = self:getPaddingTop()
    local availableWidth = self.width - self:getPaddingX()

    if self.wrap and availableWidth > 0 then
        love.graphics.printf(self.text, x, y, availableWidth, self.align)
    else
        if self.align == "center" then
            x = self.width / 2
        elseif self.align == "right" then
            x = self.width - self:getPaddingRight()
        end

        if self.verticalAlign == "middle" then
            y = self.height / 2 - self.font:getHeight() / 2
        elseif self.verticalAlign == "bottom" then
            y = self.height - self.font:getHeight() - self:getPaddingBottom()
        end

        love.graphics.print(self.text, x, y)
    end
end

return Label
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Label.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/ScrollView.lua ====

-- /src/ui/elements/ScrollView.lua

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")
local ScrollView = class("ScrollView", Element)

function ScrollView:initialize(options)
    options = options or {}
    Element.initialize(self, options)

    -- === Стилевые настройки из темы или опций ===
    self.scrollBarSize = options.scrollBarSize or self:getStyle("scrollbar_size", 8)
    self.scrollBarColor = options.scrollBarColor or self:getStyle("scrollbar_color", {0.9, 0.9, 0.3, 0.6})
    self.friction = options.friction or self:getStyle("friction", 0.95)
    self.maxVelocity = options.maxVelocity or self:getStyle("max_velocity", 1200)

    -- === Контент для прокрутки ===
    self.content = Element:new({
        x = 0,
        y = 0,
        width = self.width,
        height = 0,
        scissor = false,
        interactive = false
    })

    -- === Позиция прокрутки ===
    self.scrollY = 0
    self.maxScrollY = 0
    self.scrollX = 0
    self.maxScrollX = 0

    -- === Переменные для тач-управления ===
    self.touchId = nil
    self.lastTouchY = 0
    self.velocityY = 0

    -- === Добавляем контент как дочерний элемент ===
    --self:addChild(self.content)

    -- === Автообновление размеров ===
    if options.autoSize ~= false then
        self:updateContentSize()
    end
    
    self.scissorEnabled = true
end

-- === Добавление дочернего элемента в content ===
function ScrollView:addChild(child)
    local offsetY = 0
    if #self.content.children > 0 then
        local lastChild = self.content.children[#self.content.children]
        offsetY = lastChild.y + lastChild.height
    end
    child.x = self.content:getPaddingLeft() or 0
    child.y = offsetY
    self.content:addChild(child)
    self:updateContentSize()
end

-- === Обновление размера контента ===
function ScrollView:updateContentSize()
    self.content.contentWidth = 0
    self.content.contentHeight = 0
    for _, child in ipairs(self.content.children) do
        self.content.contentWidth = math.max(self.content.contentWidth, child.x + child.width)
        self.content.contentHeight = math.max(self.content.contentHeight, child.y + child.height)
    end
    self.maxScrollY = math.max(0, (self.content.contentHeight or 0) - (self.height - self.content:getPaddingY()))
end

-- === Обновление позиции контента при скролле ===
function ScrollView:update(dt)
    Element.update(self, dt)

    -- Инерция скроллинга
    if not self.touchId and math.abs(self.velocityY) > 1 then
        local delta = self.velocityY * dt
        self.scrollY = math.max(0, math.min(self.maxScrollY, self.scrollY + delta))
        self.velocityY = self.velocityY * self.friction
    end
end



-- === Рисование контента ===
function ScrollView:drawContent(width, height)
    
    love.graphics.translate(0, -self.scrollY)
    self:applyScissor()
    for _, child in ipairs(self.content.children) do
        child:draw()
    end
    self:clearScissor()
    self:drawScrollBar()
end

-- === Отрисовка скроллбара ===
function ScrollView:drawScrollBar()
    if self.maxScrollY == 0 then return end

    local barHeight = math.max(30, self.height * (self.height / (self.content.contentHeight + self.content:getPaddingY())))
    local scrollAreaHeight = self.height - 4
    local barPos = self.scrollY  + (self.scrollY / self.maxScrollY) * (scrollAreaHeight - barHeight)

    love.graphics.setColor(self.scrollBarColor)
    love.graphics.rectangle(
        "fill",
        self.width - self.scrollBarSize,
        barPos,
        self.scrollBarSize,
        barHeight
    )
end

-- === Обработка касаний через InteractiveEvents ===
function ScrollView:onTouchPressed(event)
    if not self:isInside(event.x, event.y) then return false end
    self.touchId = event.id
    self.lastTouchY = event.y
    self.velocityY = 0
    return true
end

function ScrollView:onTouchMoved(event)
    if event.id == self.touchId then
        local deltaY = self.lastTouchY - event.y
        self.lastTouchY = event.y
        self.scrollY = math.max(0, math.min(self.maxScrollY, self.scrollY + deltaY))
        self.velocityY = deltaY * self:getStyle("touch_scroll_multiplier", 18)
        return true
    end
    return false
end

function ScrollView:onTouchReleased(event)
    if event.id == self.touchId then
        self.touchId = nil
        return true
    end
    return false
end

return ScrollView
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/ScrollView.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====

-- /src/ui/elements/UIInputField.lua

local class = require("lib.middleclass")
local TextEditable = require("src.ui.core.mixins.TextEditable")
local Element = require("src.ui.core.Element")
local UIInputField = class("UIInputField", Element)
UIInputField:mixin(TextEditable)

function UIInputField:initialize(options)
    Element.initialize(self, options)
    TextEditable.initialize(self, options)

    self:setStyle({
        background_color = options.backgroundColor or {0.2, 0.2, 0.2, 1}
    })
end

-- === drawSelf вызывается через Element:draw(), если определён ===
function UIInputField:drawContent()
    love.graphics.setColor(0.5, 0.5, 0.5, 0.7)
    love.graphics.rectangle("fill", 0, 0, self.width, self.height)

    self:drawTextContent()
end

return UIInputField
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/fonts/init.lua ====

local Fonts = {}

function Fonts.load()
    Fonts.default = love.graphics.newFont("src/ui/fonts/font.otf", 16)
    Fonts.big = love.graphics.newFont("src/ui/fonts/font.otf", 24)
end

return Fonts
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/fonts/init.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/DebugConsole.lua ====

local DebugConsole = {
    messages = {},
    maxLines = 15,
    visible = true,
    x = 10,
    y = 10,
    width = 300,
    height = 200,
    backgroundColor = {0, 0, 0, 0.7},
    textColor = {1, 1, 1, 1},
    scrollOffset = 0,
    lastMessageTime = 0,
    autoScroll = true,
    debugTouchVisible = true,
    debugUIHierarchy = false
}

-- Логирование сообщений
function DebugConsole.log(...)
    local args = {...}
    local text = ""
    
    -- Обрабатываем все аргументы
    for i, arg in ipairs(args) do
        if i > 1 then
            text = text .. " " -- Разделитель между аргументами
        end
        text = text .. tostring(arg)
    end
    


    table.insert(DebugConsole.messages, 1, {
        text = tostring(text),
        time = love.timer.getTime()
    })
    
    -- Обрезка старых сообщений
    if #DebugConsole.messages > DebugConsole.maxLines * 3 then
        table.remove(DebugConsole.messages)
    end
    
    -- Автопрокрутка к новым сообщениям
    if DebugConsole.autoScroll then
        DebugConsole.scrollOffset = 0
    end
    
    print("[DEBUG] " .. text)
end

-- Отрисовка консоли
function DebugConsole.draw()
    if not DebugConsole.visible then return end
    
    -- Фон консоли
    love.graphics.setColor(unpack(DebugConsole.backgroundColor))
    love.graphics.rectangle("fill", DebugConsole.x, DebugConsole.y, 
                          DebugConsole.width, DebugConsole.height)
    
    -- Текст консоли
    love.graphics.setColor(unpack(DebugConsole.textColor))
    local visibleLines = math.min(DebugConsole.maxLines, #DebugConsole.messages)
    local startIndex = 1 + DebugConsole.scrollOffset
    local endIndex = math.min(startIndex + visibleLines - 1, #DebugConsole.messages)
    
    for i = startIndex, endIndex do
        local msg = DebugConsole.messages[i]
        local relIndex = i - startIndex
        love.graphics.print(msg.text, 
            DebugConsole.x + 5, 
            DebugConsole.y + 5 + relIndex * 20)
    end
    
    -- Отладочная информация (если включена)
    if DebugConsole.debugTouchVisible then
        DebugConsole.drawDebugInfo()
    end
end

-- Отладочная информация
function DebugConsole.drawDebugInfo()
    local ui = UIManager and UIManager.getInstance()
    if not ui then return end
    
    -- Последнее касание
    love.graphics.setColor(1, 0, 0, 0.5)
    love.graphics.circle("fill", ui.lastTouch.x, ui.lastTouch.y, 15)
    
    -- FPS и координаты
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("FPS: " .. love.timer.getFPS(), 10, love.graphics.getHeight() - 30)
    love.graphics.print(string.format("Touch: %d, %d", ui.lastTouch.x, ui.lastTouch.y), 
        10, love.graphics.getHeight() - 60)
end

-- Логирование иерархии UI
function DebugConsole.logUIHierarchy()
    local ui = UIManager and UIManager.getInstance()
    if not ui or not ui.root then 
        DebugConsole.log("UI Hierarchy: No root element")
        return
    end
    
    DebugConsole.log("=== UI Hierarchy ===")
    local function logElement(el, level)
        local indent = string.rep("  ", level)
        local info = string.format("%s%s [%d,%d %dx%d] %s",
            indent, tostring(el), el.x, el.y, el.width, el.height,
            el.label or "")
        DebugConsole.log(info)
        
        if el.children then
            for _, child in ipairs(el.children) do
                logElement(child, level + 1)
            end
        end
    end
    
    logElement(ui.root, 0)
end

-- Управление консолью
function DebugConsole.toggle()
    DebugConsole.visible = not DebugConsole.visible
end

function DebugConsole.toggleDebug()
    DebugConsole.debugTouchVisible = not DebugConsole.debugTouchVisible
    DebugConsole.debugUIHierarchy = not DebugConsole.debugUIHierarchy
    DebugConsole.log("Debug mode: " .. (DebugConsole.debugTouchVisible and "ON" or "OFF"))
end

-- Прокрутка консоли
function DebugConsole.scroll(direction)
    local maxOffset = math.max(0, #DebugConsole.messages - DebugConsole.maxLines)
    DebugConsole.scrollOffset = math.max(0, math.min(maxOffset, DebugConsole.scrollOffset + direction))
    DebugConsole.autoScroll = DebugConsole.scrollOffset == 0
end

-- Обработка ввода для консоли
function DebugConsole.handleInput(key)
    if key == "d" then
        DebugConsole.toggleDebug()
    elseif key == "h" then
        DebugConsole.logUIHierarchy()
    elseif key == "pageup" then
        DebugConsole.scroll(-5)
    elseif key == "pagedown" then
        DebugConsole.scroll(5)
    elseif key == "home" then
        DebugConsole.scrollOffset = 0
        DebugConsole.autoScroll = true
    elseif key == "end" then
        DebugConsole.scrollOffset = math.max(0, #DebugConsole.messages - DebugConsole.maxLines)
        DebugConsole.autoScroll = false
    end
end

-- Перемещение консоли
function DebugConsole.move(x, y)
    DebugConsole.x = math.max(0, math.min(love.graphics.getWidth() - DebugConsole.width, x))
    DebugConsole.y = math.max(0, math.min(love.graphics.getHeight() - DebugConsole.height, y))
end

return DebugConsole
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/DebugConsole.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UTF8Utils.lua ====

-- UTF8Utils.lua
local UTF8Utils = {}

-- Подсчёт количества символов в UTF-8 строке
function UTF8Utils.len(s)
    local _, count = string.gsub(s, "([%z\1-\127\194-\244][\128-\191]*)", "")
    return count
end

-- Получение i-го символа из строки
function UTF8Utils.get_char_at(s, i)
    local pos = 0
    local char_count = 0
    while pos < #s do
        char_count = char_count + 1
        local c = s:byte(pos + 1)
        local size
        if c < 128 then
            size = 1
        elseif c < 192 then
            return nil -- invalid byte
        elseif c < 224 then
            size = 2
        elseif c < 240 then
            size = 3
        elseif c < 245 then
            size = 4
        else
            return nil -- invalid byte
        end
        if char_count == i then
            return s:sub(pos + 1, pos + size)
        end
        pos = pos + size
    end
    return nil
end

-- Безопасное "utf8.sub" — работает как utf8.sub, но без использования оригинального модуля
function UTF8Utils.sub(s, start_idx, end_idx)
    local len = UTF8Utils.len(s)
    start_idx = start_idx or 1
    end_idx = end_idx or len

    if start_idx < 1 then
        start_idx = 1
    elseif start_idx > len then
        return ""
    end

    if end_idx < 1 then
        return ""
    elseif end_idx > len then
        end_idx = len
    end

    local result = ""
    for i = start_idx, end_idx do
        local c = UTF8Utils.get_char_at(s, i)
        if not c then break end
        result = result .. c
    end

    return result
end

return UTF8Utils
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UTF8Utils.lua ====

