

-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====

local UIManager = require("src.ui.core.UIManager")
local UIButton = require("src.ui.elements.UIButton")
local Fonts = require("src.ui.fonts.init")
local DebugConsole = require("src.ui.utils.DebugConsole")
local ScrollView = require("src.ui.elements.ScrollView")
local Label = require("src.ui.elements.Label")

local ui = UIManager:new()


function love.load()
    Fonts.load()
    love.graphics.setFont(Fonts.default)
    
    
    
    -- Создаем ScrollView с явным указанием options
    local scrollView = ScrollView:new(
        100, 
        100, 
        love.graphics.getWidth() - 200, 
        love.graphics.getHeight() - 200, 
        {
            zIndex = 1,
            scrollBarSize = 10,
            scrollBarColor = {0.1, 0.5, 0.2, 0.1}
        }
    )
    
    scrollView:setContentSize(love.graphics.getWidth() - 100, 2000)
    
    local Element = require("src.ui.core.Element")
        -- Добавьте это в love.load() после создания scrollView
    local testRect = Element:new(10, 10, 100, 50, {backgroundColor = {0,0.5,1,1}})
    scrollView:addChild(testRect)
    
    -- Добавляем тестовые элементы
    
    for i = 1, 50 do

        
        -- Создаем Label для текста
        local label = Label:new(
            10, 15,                      -- x, y (относительно item)
            "Элемент "..i,               -- текст
            {1,1,1,1},                -- цвет (белый)
            {                            -- опции
                zIndex = 1000,
                align = "left",
                wrap = true,
                
            }
        )
        

        
        -- Добавляем элемент в scrollView
        scrollView:addChild(label)
    end
    
    ui:addElement(scrollView)
    

    
    
    
    

    -- Кнопка консоли
    local consoleBtn = UIButton(love.graphics.getWidth() - 210, 10, 200, 40, "КОНСОЛЬ", {
        backgroundColor = {0.3, 0.3, 0.8, 1},
        textColor = {1, 1, 1, 1},
        onClick = function()
            DebugConsole.toggle()
        end
    })

    -- Тестовая кнопка
    local testBtn = UIButton(50, 400, 200, 60, "ТЕСТ", {
        backgroundColor = {0.2, 0.7, 0.2, 1},
        textColor = {1, 1, 1, 1},
        onClick = function()
            DebugConsole.log("Нажата тестовая кнопка")
            testBtn:setBackgroundColor(0.8, 0.2, 0.2, 1)
        end,
        zIndex = 1
    })

    ui:addElement(consoleBtn)
    ui:addElement(testBtn)

    DebugConsole.log("UI инициализирован через UIManager")
end

function love.update(dt)
    ui:update(dt)
    if DebugConsole.update then DebugConsole.update(dt) end
end

function love.draw()
    love.graphics.clear(0.1, 0.1, 0.15)
    ui:draw()
    DebugConsole.draw()
end

-- TOUCH (Android)
function love.touchpressed(id, x, y, dx, dy, pressure)
    ui:handleEvent({ type = "touchpressed", id = id, x = x, y = y, dx = dx, dy = dy, pressure = pressure })
end

function love.touchreleased(id, x, y, dx, dy, pressure)
    ui:handleEvent({ type = "touchreleased", id = id, x = x, y = y, dx = dx, dy = dy, pressure = pressure })
end

function love.touchmoved(id, x, y, dx, dy, pressure)
    ui:handleEvent({ type = "touchmoved", id = id, x = x, y = y, dx = dx, dy = dy, pressure = pressure })
end
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====

local class = require("lib.middleclass")
local EventDispatcher = require("src.ui.core.EventDispatcher")

-- Подключаем миксины
local Hierarchy = require("src.ui.core.mixins.Hierarchy")
local Visibility = require("src.ui.core.mixins.Visibility")
local Geometry = require("src.ui.core.mixins.Geometry")
local ZIndex = require("src.ui.core.mixins.ZIndex")
local Interactivity = require("src.ui.core.mixins.Interactivity")
local ContentLayout = require("src.ui.core.mixins.ContentLayout")

local Element = class("Element")
EventDispatcher.mixin(Element)




local class = require("lib.middleclass")
local EventDispatcher = require("src.ui.core.EventDispatcher")

Element.static.mixins = {Hierarchy, Visibility, Geometry, ZIndex, Interactivity, ContentLayout}

function Element:initialize(x, y, w, h, options)
    self:initMixins()
    self.x = x or 0
    self.y = y or 0
    self.width = w or 0
    self.height = h or 0
    self.zIndex = options and options.zIndex or 0
    


end

function Element:initMixins()
  for _, mixin in ipairs(Element.static.mixins) do
        if mixin.init then
            mixin.init(self)  -- Инициализация каждого миксина
        end
        -- Также добавляем методы из миксинов в текущий объект
        for k, v in pairs(mixin) do
            if not self[k] then
                self[k] = v  -- Только если метод еще не существует
            end
        end
    end

    EventDispatcher.initialize(self)
end

-- Обработка события
function Element:handleEvent(event)
-- Рассчитываем глобальные координаты с учетом родителей
local globalX, globalY = self:toGlobal(event.x, event.y)

-- Проверка попадания в элемент 
if event.x and event.y and not self:isInside(globalX, globalY) then return false -- событие не попало в элемент 
end -- Обновляем локальные координаты относительно текущего элемента 
event.localX = globalX - self.x event.localY = globalY - self.y -- Передаем событие в EventDispatcher 
return self:dispatchEvent(event) 

end

function Element:draw()
    if not self.visible then return end

    love.graphics.setColor(0.7, 0.6, 0.4, 1) -- hsl(256,66.6%,48.1%)
    love.graphics.rectangle("line", self.x, self.y, self.width, self.height)
    

    if not self._childrenSorted then
        self:sortChildren()
    end
    
    
    self:drawSelf()

    -- Рисуем дочерние элементы
    if self.children then
        
        for _, child in ipairs(self.children) do
          
            require("src.ui.utils.DebugConsole").log("draw", child.x, child.y, child.width, child.height)
            
            self.updateContentSize()
            child:draw()
            
        end
    end
end

function Element:drawSelf()
  print("test")
end


return Element
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/EventDispatcher.lua ====

local EventDispatcher = {}

function EventDispatcher:initialize()
    self._listeners = {}  -- Слушатели для текущего элемента
end

-- Добавление слушателя
function EventDispatcher:addEventListener(eventType, callback)
    assert(type(callback) == "function", "Callback must be a function")
    if not self._listeners[eventType] then
        self._listeners[eventType] = {}
    end
    table.insert(self._listeners[eventType], callback)
end

-- Удаление слушателя
function EventDispatcher:removeEventListener(eventType, callback)
    local listeners = self._listeners[eventType]
    if not listeners then return end
    for i = #listeners, 1, -1 do
        if listeners[i] == callback then
            table.remove(listeners, i)
            break
        end
    end
end

-- Диспетчеризация события
function EventDispatcher:dispatchEvent(event)
    -- Валидация входящего события
    assert(type(event) == "table", "Event must be a table")
    assert(event.type, "Event must have a type")

    -- Инициализация свойств события
    event.target = event.target or self
    event.currentTarget = self
    event._stopped = false
    event.stopPropagation = function() 
        event._stopped = true 
    end

    -- Проверка возможности обработки события
    if not self:canHandleEvent(event) then
        return false
    end

    -- Обработка локальных слушателей
    local listeners = self._listeners[event.type]
    if listeners then
        -- Создаем копию списка слушателей на случай его изменения во время обработки
        local listenersCopy = {unpack(listeners)}
        for _, callback in ipairs(listenersCopy) do
            if not event._stopped then
                callback(event)
            end
        end
    end

    -- Обработка всплытия (если не было остановки)
    if not event._stopped then

        if self.parent and event.bubbles ~= false then
             return self.parent:dispatchEvent(event)
        end
    end

    -- Возвращаем true, если событие не было остановлено
    return not event._stopped
end

-- Метод для добавления миксина
function EventDispatcher.mixin(target)
    target.initialize = EventDispatcher._wrapInit(target.initialize)
    for k, v in pairs(EventDispatcher) do
        if k ~= "mixin" and k ~= "_wrapInit" then
            target[k] = v
        end
    end
end

-- Обёртка для инициализации
function EventDispatcher._wrapInit(origInit)
    return function(self, ...)
        if origInit then origInit(self, ...) end
        EventDispatcher.initialize(self)
    end
end

-- Проверка, можно ли обработать событие
function EventDispatcher:canHandleEvent(event)
    return self.visible and self.enabled  -- проверка видимости и активности
end

return EventDispatcher
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/EventDispatcher.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====

local UIManager = {}
UIManager.__index = UIManager

function UIManager:new()
    local obj = {
        elements = {},
        sorted = false
    }
    setmetatable(obj, self)
    return obj
end

function UIManager:addElement(element)
    table.insert(self.elements, element)
    self.needsSort = true  -- Флаг для отложенной сортировки
end

function UIManager:removeElement(element)
    for i, el in ipairs(self.elements) do
        if el == element then
            table.remove(self.elements, i)
            self.needsSort = true
            break
        end
    end
end

function UIManager:sortElements()
    table.sort(self.elements, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self.needsSort = false
end

function UIManager:draw()
    if self.needsSort then
        self:sortElements()
    end

    for _, el in ipairs(self.elements) do
        if el.draw then el:draw() end
    end
end

function UIManager:sortByZIndex()
    table.sort(self.elements, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self.sorted = true
end

function UIManager:update(dt)
    for _, el in ipairs(self.elements) do
        if el.update then el:update(dt) end
    end
end


function UIManager:handleEvent(event)
    if not self.sorted then
        self:sortByZIndex()
    end

    -- Перебираем от верхнего к нижнему
    for i = #self.elements, 1, -1 do
        local el = self.elements[i]
        if el.handleEvent and el.isInside and event.x and event.y then
            if el:isInside(event.x, event.y) then
                if el:handleEvent(event) then
                    return true -- событие обработано, не передаём дальше
                end
            end
        end
    end
    return false
end

function UIManager:setFocus(element)
    if self.focused == element then
        return  -- уже в фокусе
    end

    -- Снимаем фокус с предыдущего элемента и его родителей
    if self.focused then
        local oldFocus = self.focused
        oldFocus.hasFocus = false
        oldFocus:dispatchEvent({ type = "focuslost" })

        -- Всплытие focuslost для родителей
        local parent = oldFocus.parent
        while parent do
            parent:dispatchEvent({ type = "focuslost", bubbles = true })
            parent = parent.parent
        end
    end

    -- Устанавливаем фокус на новый элемент
    self.focused = element
    if element then
        element.hasFocus = true
        element:dispatchEvent({ type = "focusgained" })

        -- Всплытие focusgained для родителей
        local parent = element.parent
        while parent do
            parent:dispatchEvent({ type = "focusgained", bubbles = true })
            parent = parent.parent
        end
    end
end

return UIManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ContentLayout.lua ====

local ContentLayout = {}

function ContentLayout:init()
    self.contentWidth = 0
    self.contentHeight = 0
    self.padding = 0
end

function ContentLayout:updateContentSize()
    self.contentWidth = 0
    self.contentHeight = 0
    for _, child in ipairs(self.children) do
        self.contentWidth = math.max(self.contentWidth, child.x + child.width)
        self.contentHeight = math.max(self.contentHeight, self.contentHeight + child.height)
    end
end

return ContentLayout
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ContentLayout.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Geometry.lua ====

local Geometry = {}

function Geometry:init()
    self.x = 0
    self.y = 0
    self.width = 0
    self.height = 0
end

function Geometry:isInside(x, y)
    return x >= self.x and y >= self.y and x <= self.x + self.width and y <= self.y + self.height
end

function Geometry:toGlobal(x, y)
    local node = self
    while node.parent do
        x = x + node.parent.x
        y = y + node.parent.y
        node = node.parent
    end
    return x, y
end

return Geometry
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Geometry.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Hierarchy.lua ====

local Hierarchy = {}

function Hierarchy:init()
    self.parent = nil
    self.children = {}
end

function Hierarchy:addChild(child)
    if not child then
        require("src.ui.utils.DebugConsole").log( "Child cannot be nil")
        return 
    end
    
    if child.parent then
        child.parent:removeChild(child)
    end
    child.parent = self
    child.x = self.padding or 0
    child.y = (self.contentHeight or 0) + (self.padding or 0)
    table.insert(self.children, child)
    
    
    
    if self.updateContentSize then self:updateContentSize() end
    if self.sortChildren then self:sortChildren() end
end

function Hierarchy:removeChild(child)
    for i, c in ipairs(self.children) do
        if c == child then
            table.remove(self.children, i)
            c.parent = nil
            return
        end
    end
end

function Hierarchy:sortChildren()
    table.sort(self.children, function(a, b)
        return (a.zIndex or 0) < (b.zIndex or 0)
    end)
    self._childrenSorted = true
end

function Hierarchy:getRoot()
    local node = self
    while node.parent do
        node = node.parent
    end
    return node
end

return Hierarchy
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Hierarchy.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Interactivity.lua ====

local Interactivity = {}

function Interactivity:init()
    self.enabled = true
end

function Interactivity:enable()
    self.enabled = true
    return self
end

function Interactivity:disable()
    self.enabled = false
    return self
end

return Interactivity
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Interactivity.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Visibility.lua ====

local Visibility = {}

function Visibility:init()
    self.visible = true
end

function Visibility:show()
    self.visible = true
    return self
end

function Visibility:hide()
    self.visible = false
    return self
end

return Visibility
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/Visibility.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ZIndex.lua ====

local ZIndex = {}

function ZIndex:init()
    self.zIndex = 0
end

function ZIndex:setZIndex(value)
    self.zIndex = value or 0
    if self.parent then
        self.parent:sortChildren()
    end
end

return ZIndex
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/mixins/ZIndex.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Label.lua ====

local Element = require("src.ui.core.Element")
local class = require("lib.middleclass")

local Label = class("Label", Element)

function Label:initialize(x, y, text, color, options)
    options = options or {}
    Element.initialize(self, x, y, 0, 0, options) -- Ширина и высота будут вычислены при установке текста
    
    self.text = text or ""
    self.font = love.graphics.getFont()
    self.color = color or {1, 1, 1, 1} -- Белый цвет по умолчанию
    self.align = options.align or "left" -- left, center, right
    self.wrap = options.wrap or false -- Перенос текста
    self.limit = options.limit -- Максимальная ширина текста
    
    -- Вычисляем размеры при инициализации
    self:updateDimensions()
end

-- Обновляет размеры label в соответствии с текстом
function Label:updateDimensions()
    if not self.font then return end
    
    if self.wrap and self.limit then
        self.width = self.limit
        local _, wrapped = self.font:getWrap(self.text, self.limit)
        self.height = #wrapped * self.font:getHeight()
    else
        self.width = self.font:getWidth(self.text)
        self.height = self.font:getHeight()
    end
end

-- Устанавливает текст и обновляет размеры
function Label:setText(text)
    self.text = text or ""
    self:updateDimensions()
    return self
end

-- Устанавливает шрифт и обновляет размеры
function Label:setFont(font)
    self.font = font or love.graphics.getFont()
    self:updateDimensions()
    return self
end

-- Устанавливает цвет текста
function Label:setColor(color)
    self.color = color or {1, 1, 1, 1}
    return self
end

-- Устанавливает выравнивание текста
function Label:setAlign(align)
    self.align = align or "left"
    return self
end

-- Отрисовка label
function Label:drawSelf()
    
    if not self.visible or not self.font or #self.text == 0 then return end
    
    
    
    local oldColor = {love.graphics.getColor()}
    love.graphics.setFont(self.font)
    love.graphics.setColor(self.color)
    
    if self.wrap and self.limit then
        love.graphics.printf(self.text, self.x, self.y, self.limit, self.align)
    else
        local x = self.x
        if self.align == "center" then
            x = x + (self.width / 2)
        elseif self.align == "right" then
            x = x + self.width
        end
        
        love.graphics.print(self.text, x, self.y, 0, 1, 1, 
                           self.align == "center" and self.width/2 or 
                           self.align == "right" and self.width or 0)
    end
    
    love.graphics.setColor(oldColor)
end

return Label
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/Label.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/ScrollView.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local ScrollView = class("ScrollView", Element)

function ScrollView:initialize(x, y, w, h, options)
    options = options or {}
    Element:initialize(x, y, w, h, options)
    self.content = Element:new(10, 10, w - 10, h + 10, {})
    
    -- Параметры прокрутки
    self.scrollY = 0
    self.maxScrollY = 0
    self.scrollBarVisible = false
    self.scrollBarSize = options.scrollBarSize or 10
    self.scrollBarColor = options.scrollBarColor or {0.1, 0.5, 0.5, 0.5}
    self.scrollBarMargin = options.scrollBarMargin or 2
    
    -- Для тач-событий и инерции
    self.touchId = nil
    self.lastTouchY = 0
    self.velocityY = 0
    self.friction = 0.92
    self.maxVelocity = 1000
    
    -- Обработчики событий
    self:addEventListener("touchpressed", function(e) return self:onTouchPressed(e) end)
    self:addEventListener("touchreleased", function(e) return self:onTouchReleased(e) end)
    self:addEventListener("touchmoved", function(e) return self:onTouchMoved(e) end)
    
    self:addChild(self.content)
    
    require("src.ui.utils.DebugConsole").log( "Child: ".. tostring(#self.children))
end

function ScrollView:setContentSize(w, h)

end

function ScrollView:updateScrollLimits()
    self.maxScrollY = math.max(0, (self.content.contentHeight or 0) - self.height)
    self.scrollY = math.max(0, math.min(self.scrollY, self.maxScrollY))
    self.scrollBarVisible = self.maxScrollY > 0
end

function ScrollView:update(dt)
    if not self.touchId and math.abs(self.velocityY) > 1 then
        local delta = self.velocityY * dt * 60
        self.scrollY = self.scrollY + delta
        self.velocityY = self.velocityY * self.friction
        
        if self.scrollY < 0 then
            self.scrollY = self.scrollY * 0.3
            self.velocityY = 0
        elseif self.scrollY > self.maxScrollY then
            self.scrollY = self.maxScrollY + (self.scrollY - self.maxScrollY) * 0.3
            self.velocityY = 0
        end
        
        self:updateScrollLimits()
    end
end

-- Обработчики тач-событий
function ScrollView:onTouchPressed(event)
    if not self:isInside(event.x, event.y) then return false end
    
    if not self.touchId then
        self.touchId = event.id
        self.lastTouchY = event.y
        self.velocityY = 0
        return true
    end
    return false
end

function ScrollView:onTouchReleased(event)
    if event.id == self.touchId then
        self.touchId = nil
        return true
    end
    return false
end

function ScrollView:onTouchMoved(event)
    if event.id == self.touchId then
        local deltaY = self.lastTouchY - event.y
        self.lastTouchY = event.y
        
        self.velocityY = math.max(-self.maxVelocity, math.min(self.maxVelocity, deltaY * 15))
        self.scrollY = self.scrollY + deltaY
        self:updateScrollLimits()
        return true
    end
    return false
end

function ScrollView:drawSelf()
    
    self.content.height = self.contentHeight
  
    -- Включаем обрезку по области ScrollView
    love.graphics.setScissor(self.x, self.y, self.width, self.height)
    
    -- Рисуем фон
    love.graphics.setColor(0.9, 0.9, 0.9, 1)
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    
    -- Сохраняем текущие настройки графики
    love.graphics.push()
    
    -- Смещаем начало координат для контента с учетом позиции ScrollView
    love.graphics.translate(self.x, self.y - self.scrollY)
    
    -- Рисуем контент (все дочерние элементы content)
    -- Передаем 0,0 так как уже сделали трансляцию
    self.content:drawSelf()
    
    -- Восстанавливаем настройки графики
    love.graphics.pop()
    
    -- Выключаем обрезку
    love.graphics.setScissor()
    
    -- Рисуем полосу прокрутки
    if self.scrollBarVisible and self.maxScrollY > 0 then
        local scrollAreaHeight = self.height - self.scrollBarMargin * 2
        local scrollBarHeight = math.max(30, scrollAreaHeight * (self.height / (self.content.contentHeight or self.height)))
        local scrollBarPos = self.scrollBarMargin + (self.scrollY / self.maxScrollY) * (scrollAreaHeight - scrollBarHeight)
        
        love.graphics.setColor(self.scrollBarColor)
        love.graphics.rectangle("fill", 
            self.x + self.width - self.scrollBarSize - self.scrollBarMargin, 
            self.y + scrollBarPos, 
            self.scrollBarSize, 
            scrollBarHeight)
    end
end

-- Методы для работы с дочерними элементами
function ScrollView:addChild(child)
    
    self.content:addChild(child)
    self:updateScrollLimits()
end

function ScrollView:removeChild(child)
    self.content:removeChild(child)
    self:updateScrollLimits()
end

return ScrollView
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/ScrollView.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIButton.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local Button = class("Button", Element)

function Button:initialize(x, y, w, h, text, options)
    Element.initialize(self, x, y, w, h, options)
    self.text = text or "Button"
    self.pressed = false
    self.onClick = options and options.onClick
    self.backgroundColor = options and options.backgroundColor or {0.5, 0.5, 0.5, 1}
    self.textColor = options and options.textColor or {1, 1, 1, 1}

    self:addEventListener("touchpressed", function(event)
        if self:isInside(event.x, event.y) then
            require("src.ui.utils.DebugConsole").log("press")
            self.pressed = true
        end
    end)

    self:addEventListener("touchreleased", function(event)
        if self.pressed and self:isInside(event.x, event.y) then
            self.pressed = false
            if self.onClick then self.onClick(self, event) end
        else
            self.pressed = false
        end
    end)
end

function Button:draw()
    if not self.visible then return end

    local bgColor = self.pressed and {0.4, 0.4, 1} or {0.2, 0.2, 0.8}
    love.graphics.setColor(bgColor)
    love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)

    love.graphics.setColor(1, 1, 1)
    love.graphics.printf(self.text, self.x, self.y + self.height / 2 - 6, self.width, "center")

    -- Debug frame
    love.graphics.setColor(1, 1, 1, 0.5)
    love.graphics.rectangle("line", self.x, self.y, self.width, self.height)

    -- Отрисовка дочерних (если есть)
    for _, child in ipairs(self.children) do
        child:draw()
    end
end

return Button
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIButton.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UIInputField = class("UIInputField", Element)

function UIInputField:initialize(x, y, width, height, options)
    Element.initialize(self, x, y, width, height)
    
    options = options or {}
    
    -- Свойства текста
    self.text = options.text or ""
    self.placeholder = options.placeholder or ""
    self.font = options.font or love.graphics.getFont()
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.placeholderColor = options.placeholderColor or {0.7, 0.7, 0.7, 1}
    
    -- Внешний вид
    self.backgroundColor = options.backgroundColor or {0.2, 0.2, 0.2, 1}
    self.borderColor = options.borderColor or {0.5, 0.5, 0.5, 1}
    self.focusBorderColor = options.focusBorderColor or {0.7, 0.7, 1, 1}
    self.borderWidth = options.borderWidth or 1
    self.borderRadius = options.borderRadius or 2
    self.padding = options.padding or 5
    
    -- Состояние
    self.hasFocus = false
    self.cursorPos = #self.text
    self.cursorVisible = true
    self.cursorBlinkTime = 0.5
    self.cursorTimer = 0
    self.passwordMode = options.passwordMode or false
    self.maxLength = options.maxLength or -1
    
    -- Фильтрация ввода
    self.inputFilter = options.inputFilter -- функция для фильтрации символов
    
    -- Callback
    self.onTextChanged = options.onTextChanged
    self.onEnterPressed = options.onEnterPressed
end

function UIInputField:getText()
    return self.text
end

function UIInputField:setText(text)
    self.text = text or ""
    self.cursorPos = math.min(self.cursorPos, #self.text)
    
    if self.onTextChanged then
        self.onTextChanged(self, self.text)
    end
end

function UIInputField:setPlaceholder(placeholder)
    self.placeholder = placeholder or ""
end

function UIInputField:onFocus()
    self.hasFocus = true
    self.cursorTimer = 0
    self.cursorVisible = true
end

function UIInputField:onBlur()
    self.hasFocus = false
end

-- Обработка текстового ввода
function UIInputField:textinput(text)
    if not self.hasFocus then return end
    
    -- Применяем фильтр ввода при необходимости
    if self.inputFilter and not self.inputFilter(text) then
        return
    end
    
    -- Проверяем макс. длину
    if self.maxLength > 0 and #self.text >= self.maxLength then
        return
    end
    
    -- Добавляем текст в текущую позицию курсора
    local newText = string.sub(self.text, 1, self.cursorPos) .. text .. string.sub(self.text, self.cursorPos + 1)
    self:setText(newText)
    self.cursorPos = self.cursorPos + #text
end

-- Обработка нажатия клавиш
function UIInputField:keypressed(key, scancode, isrepeat)
    if not self.hasFocus then return end
    
    if key == "backspace" then
        if self.cursorPos > 0 then
            local newText = string.sub(self.text, 1, self.cursorPos - 1) .. string.sub(self.text, self.cursorPos + 1)
            self:setText(newText)
            self.cursorPos = self.cursorPos - 1
        end
    elseif key == "delete" then
        if self.cursorPos < #self.text then
            local newText = string.sub(self.text, 1, self.cursorPos) .. string.sub(self.text, self.cursorPos + 2)
            self:setText(newText)
        end
    elseif key == "left" then
        self.cursorPos = math.max(0, self.cursorPos - 1)
    elseif key == "right" then
        self.cursorPos = math.min(#self.text, self.cursorPos + 1)
    elseif key == "home" then
        self.cursorPos = 0
    elseif key == "end" then
        self.cursorPos = #self.text
    elseif key == "return" or key == "kpenter" then
        if self.onEnterPressed then
            self.onEnterPressed(self, self.text)
        end
    end
    
    -- Сбрасываем таймер моргания курсора
    self.cursorTimer = 0
    self.cursorVisible = true
end

function UIInputField:onTouchPressed(id, x, y, dx, dy, pressure)
    if self:isInside(x, y) then
        self:focus()
        
        -- Установка позиции курсора по клику
        local clickX = x - self.x - self.padding
        local currentPos = 0
        local bestDist = math.huge
        
        for i = 0, #self.text do
            local textPart = self.passwordMode and string.rep("*", i) or string.sub(self.text, 1, i)
            local width = self.font:getWidth(textPart)
            local dist = math.abs(width - clickX)
            
            if dist < bestDist then
                bestDist = dist
                currentPos = i
            end
        end
        
        self.cursorPos = currentPos
        return true
    else
        if self.hasFocus then
            self:blur()
        end
        return false
    end
end

function UIInputField:update(dt)
    Element.update(self, dt)
    
    -- Обновление курсора
    if self.hasFocus then
        self.cursorTimer = self.cursorTimer + dt
        if self.cursorTimer >= self.cursorBlinkTime then
            self.cursorTimer = self.cursorTimer - self.cursorBlinkTime
            self.cursorVisible = not self.cursorVisible
        end
    end
end

function UIInputField:draw()
    if not self.visible then return end
    
    -- Сохраняем текущие настройки графики
    local r, g, b, a = love.graphics.getColor()
    local currentFont = love.graphics.getFont()
    
    -- Рисуем фон
    love.graphics.setColor(unpack(self.backgroundColor))
    
    if self.borderRadius > 0 and love.graphics.newCanvas then
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
    else
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Рисуем границу
    local borderColor = self.hasFocus and self.focusBorderColor or self.borderColor
    love.graphics.setColor(unpack(borderColor))
    
    if self.borderRadius > 0 and love.graphics.newCanvas then
        love.graphics.rectangle("line", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
    else
        love.graphics.rectangle("line", self.x, self.y, self.width, self.height)
    end
    
    -- Устанавливаем шрифт
    love.graphics.setFont(self.font)
    
    -- Определяем, какой текст отображать
    local displayText = self.text
    if self.passwordMode then
        displayText = string.rep("*", #self.text)
    end
    
    -- Вычисляем область отображения текста
    local textX = self.x + self.padding
    local textY = self.y + (self.height - self.font:getHeight()) / 2
    
    -- Рисуем текст или плейсхолдер
    if #self.text > 0 then
        love.graphics.setColor(unpack(self.textColor))
        love.graphics.print(displayText, textX, textY)
    else
        love.graphics.setColor(unpack(self.placeholderColor))
        love.graphics.print(self.placeholder, textX, textY)
    end
    
    -- Рисуем курсор, если поле в фокусе
    if self.hasFocus and self.cursorVisible then
        local cursorX = textX
        if #self.text > 0 and self.cursorPos > 0 then
            local textBeforeCursor = self.passwordMode and string.rep("*", self.cursorPos) or string.sub(self.text, 1, self.cursorPos)
            cursorX = textX + self.font:getWidth(textBeforeCursor)
        end
        
        love.graphics.setColor(unpack(self.textColor))
        love.graphics.rectangle("fill", cursorX, textY, 1, self.font:getHeight())
    end
    
    -- Восстанавливаем настройки графики
    love.graphics.setColor(r, g, b, a)
    love.graphics.setFont(currentFont)
    
    -- Рисуем дочерние элементы
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

function UIInputField:focus()
    Element.focus(self)
end

function UIInputField:blur()
    if self.parent and self.parent.clearFocus then
        self.parent:clearFocus()
    end
end

return UIInputField
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UILabel.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UILabel = class("UILabel", Element)

function UILabel:initialize(x, y, text, options)
    options = options or {}
    local width = options.width or 100
    local height = options.height or 30
    
    Element.initialize(self, x, y, width, height)
    
    -- Свойства
    self.text = text or ""
    self.options = options
    self.font = options.font or love.graphics.getFont()
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.backgroundColor = options.backgroundColor or {0, 0, 0, 0} -- Прозрачный по умолчанию
    self.textAlign = options.textAlign or "left" -- left, center, right
    self.verticalAlign = options.verticalAlign or "middle" -- top, middle, bottom
    self.padding = options.padding or {left = 5, top = 5, right = 5, bottom = 5}
    
    -- Если ширина не задана явно, устанавливаем по размеру текста
    if not options.width then
        self:updateDimensions()
    end
end

function UILabel:setText(text)
    self.text = text
    if not self.options.width then
        self:updateDimensions()
    end
end

function UILabel:setFont(font)
    self.font = font
    if not self.options.width then
        self:updateDimensions()
    end
end

function UILabel:updateDimensions()
    if self.font then
        self.width = self.font:getWidth(self.text) + self.padding.left + self.padding.right
        self.height = self.font:getHeight() + self.padding.top + self.padding.bottom
    end
end

function UILabel:draw()
    if not self.visible then return end
    
    -- Сохраняем текущие настройки графики
    local r, g, b, a = love.graphics.getColor()
    local currentFont = love.graphics.getFont()
    
    -- Рисуем фон, если он не полностью прозрачный
    if self.backgroundColor[4] > 0 then
        love.graphics.setColor(unpack(self.backgroundColor))
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Устанавливаем шрифт и цвет текста
    love.graphics.setFont(self.font)
    love.graphics.setColor(unpack(self.textColor))
    
    -- Вычисляем X-координату текста на основе выравнивания
    local textX = self.x + self.padding.left
    local textWidth = self.font:getWidth(self.text)
    
    if self.textAlign == "center" then
        textX = self.x + (self.width - textWidth) / 2
    elseif self.textAlign == "right" then
        textX = self.x + self.width - textWidth - self.padding.right
    end
    
    -- Вычисляем Y-координату текста на основе вертикального выравнивания
    local textY = self.y + self.padding.top
    local textHeight = self.font:getHeight()
    
    if self.verticalAlign == "middle" then
        textY = self.y + (self.height - textHeight) / 2
    elseif self.verticalAlign == "bottom" then
        textY = self.y + self.height - textHeight - self.padding.bottom
    end
    
    -- Рисуем текст
    love.graphics.print(self.text, textX, textY)
    
    -- Восстанавливаем настройки графики
    love.graphics.setColor(r, g, b, a)
    love.graphics.setFont(currentFont)
    
    -- Рисуем дочерние элементы (если есть)
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

return UILabel
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UILabel.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/fonts/init.lua ====

local Fonts = {}

function Fonts.load()
    Fonts.default = love.graphics.newFont("src/ui/fonts/font.otf", 16)
    Fonts.big = love.graphics.newFont("src/ui/fonts/font.otf", 24)
end

return Fonts
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/fonts/init.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/DebugConsole.lua ====

local DebugConsole = {
    messages = {},
    maxLines = 15,
    visible = true,
    x = 10,
    y = 10,
    width = 300,
    height = 200,
    backgroundColor = {0, 0, 0, 0.7},
    textColor = {1, 1, 1, 1},
    scrollOffset = 0,
    lastMessageTime = 0,
    autoScroll = true,
    debugTouchVisible = true,
    debugUIHierarchy = false
}

-- Логирование сообщений
function DebugConsole.log(...)
    local args = {...}
    local text = ""
    
    -- Обрабатываем все аргументы
    for i, arg in ipairs(args) do
        if i > 1 then
            text = text .. " " -- Разделитель между аргументами
        end
        text = text .. tostring(arg)
    end
    


    table.insert(DebugConsole.messages, 1, {
        text = tostring(text),
        time = love.timer.getTime()
    })
    
    -- Обрезка старых сообщений
    if #DebugConsole.messages > DebugConsole.maxLines * 3 then
        table.remove(DebugConsole.messages)
    end
    
    -- Автопрокрутка к новым сообщениям
    if DebugConsole.autoScroll then
        DebugConsole.scrollOffset = 0
    end
    
    print("[DEBUG] " .. text)
end

-- Отрисовка консоли
function DebugConsole.draw()
    if not DebugConsole.visible then return end
    
    -- Фон консоли
    love.graphics.setColor(unpack(DebugConsole.backgroundColor))
    love.graphics.rectangle("fill", DebugConsole.x, DebugConsole.y, 
                          DebugConsole.width, DebugConsole.height)
    
    -- Текст консоли
    love.graphics.setColor(unpack(DebugConsole.textColor))
    local visibleLines = math.min(DebugConsole.maxLines, #DebugConsole.messages)
    local startIndex = 1 + DebugConsole.scrollOffset
    local endIndex = math.min(startIndex + visibleLines - 1, #DebugConsole.messages)
    
    for i = startIndex, endIndex do
        local msg = DebugConsole.messages[i]
        local relIndex = i - startIndex
        love.graphics.print(msg.text, 
            DebugConsole.x + 5, 
            DebugConsole.y + 5 + relIndex * 20)
    end
    
    -- Отладочная информация (если включена)
    if DebugConsole.debugTouchVisible then
        DebugConsole.drawDebugInfo()
    end
end

-- Отладочная информация
function DebugConsole.drawDebugInfo()
    local ui = UIManager and UIManager.getInstance()
    if not ui then return end
    
    -- Последнее касание
    love.graphics.setColor(1, 0, 0, 0.5)
    love.graphics.circle("fill", ui.lastTouch.x, ui.lastTouch.y, 15)
    
    -- FPS и координаты
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("FPS: " .. love.timer.getFPS(), 10, love.graphics.getHeight() - 30)
    love.graphics.print(string.format("Touch: %d, %d", ui.lastTouch.x, ui.lastTouch.y), 
        10, love.graphics.getHeight() - 60)
end

-- Логирование иерархии UI
function DebugConsole.logUIHierarchy()
    local ui = UIManager and UIManager.getInstance()
    if not ui or not ui.root then 
        DebugConsole.log("UI Hierarchy: No root element")
        return
    end
    
    DebugConsole.log("=== UI Hierarchy ===")
    local function logElement(el, level)
        local indent = string.rep("  ", level)
        local info = string.format("%s%s [%d,%d %dx%d] %s",
            indent, tostring(el), el.x, el.y, el.width, el.height,
            el.label or "")
        DebugConsole.log(info)
        
        if el.children then
            for _, child in ipairs(el.children) do
                logElement(child, level + 1)
            end
        end
    end
    
    logElement(ui.root, 0)
end

-- Управление консолью
function DebugConsole.toggle()
    DebugConsole.visible = not DebugConsole.visible
end

function DebugConsole.toggleDebug()
    DebugConsole.debugTouchVisible = not DebugConsole.debugTouchVisible
    DebugConsole.debugUIHierarchy = not DebugConsole.debugUIHierarchy
    DebugConsole.log("Debug mode: " .. (DebugConsole.debugTouchVisible and "ON" or "OFF"))
end

-- Прокрутка консоли
function DebugConsole.scroll(direction)
    local maxOffset = math.max(0, #DebugConsole.messages - DebugConsole.maxLines)
    DebugConsole.scrollOffset = math.max(0, math.min(maxOffset, DebugConsole.scrollOffset + direction))
    DebugConsole.autoScroll = DebugConsole.scrollOffset == 0
end

-- Обработка ввода для консоли
function DebugConsole.handleInput(key)
    if key == "d" then
        DebugConsole.toggleDebug()
    elseif key == "h" then
        DebugConsole.logUIHierarchy()
    elseif key == "pageup" then
        DebugConsole.scroll(-5)
    elseif key == "pagedown" then
        DebugConsole.scroll(5)
    elseif key == "home" then
        DebugConsole.scrollOffset = 0
        DebugConsole.autoScroll = true
    elseif key == "end" then
        DebugConsole.scrollOffset = math.max(0, #DebugConsole.messages - DebugConsole.maxLines)
        DebugConsole.autoScroll = false
    end
end

-- Перемещение консоли
function DebugConsole.move(x, y)
    DebugConsole.x = math.max(0, math.min(love.graphics.getWidth() - DebugConsole.width, x))
    DebugConsole.y = math.max(0, math.min(love.graphics.getHeight() - DebugConsole.height, y))
end

return DebugConsole
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/DebugConsole.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====

