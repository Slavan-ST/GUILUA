

-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====

local UIManager = require("src.ui.core.UIManager")
local UIButton = require("src.ui.elements.UIButton")
local UILabel = require("src.ui.elements.UILabel")
local LayeredManager = require("src.ui.core.LayeredManager")

function love.load()
    -- Получаем экземпляр UIManager
    local ui = UIManager.getInstance()
    ui:init(love.graphics.getWidth(), love.graphics.getHeight())
    
    -- Получаем layeredManager для прямого добавления элементов
    local layeredManager = ui.layeredManager
    
    -- Создаем элементы
    local title = UILabel(20, 20, "GUI System Demo", {
        font = love.graphics.newFont(24),
        textColor = {1, 1, 1, 1}
    })
    
    local testButton = UIButton(20, 80, 200, 50, "Click Me!", {
        backgroundColor = {0.2, 0.6, 0.2, 1},
        onClick = function(self)
            print("Button clicked!")
        end
    })

    -- Добавляем элементы напрямую в layeredManager
    layeredManager:addElementToLayer(title, "default")
    layeredManager:addElementToLayer(testButton, "default")
    
    -- Отладочный вывод
    print("UI elements added to layeredManager")
    print("Title visible:", title.visible)
    print("Button visible:", testButton.visible)
end

function love.update(dt)
    UIManager.getInstance():update(dt)
end

function love.draw()
    -- Очистка экрана
    love.graphics.clear(0.1, 0.1, 0.15)
    
    -- Отрисовка UI через UIManager
    UIManager.getInstance():draw()
    
    -- Отладочная информация
    love.graphics.setColor(1, 1, 1)
    love.graphics.print("GUI Test Running", 10, love.graphics.getHeight() - 30)
end

function love.resize(w, h)
    UIManager.getInstance():init(w, h)
end
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/main.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/ContainerElement.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local ContainerElement = class("ContainerElement", Element)

function ContainerElement:initialize(x, y, w, h)
    Element.initialize(self, x, y, w, h)
end

function ContainerElement:addChild(child)
    Element.addChild(self, child)
end

function ContainerElement:removeChild(child)
    Element.removeChild(self, child)
end

function ContainerElement:update(dt)
    if not self.visible then return end
    if self.onUpdate then self:onUpdate(dt) end
    for _, child in ipairs(self.children) do
        if child.update then
            child:update(dt)
        end
    end
end

function ContainerElement:draw()
    if not self.visible then return end
    if self.onDraw then self:onDraw() end
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

-- Пробрасываем касания детям
function ContainerElement:touchPressed(id, x, y, dx, dy, pressure)
    for i = #self.children, 1, -1 do
        local child = self.children[i]
        if child.touchPressed and child:touchPressed(id, x, y, dx, dy, pressure) then
            return true
        end
    end
    return false
end

function ContainerElement:touchReleased(id, x, y, dx, dy, pressure)
    for i = #self.children, 1, -1 do
        local child = self.children[i]
        if child.touchReleased and child:touchReleased(id, x, y, dx, dy, pressure) then
            return true
        end
    end
    return false
end

function ContainerElement:touchMoved(id, x, y, dx, dy, pressure)
    for i = #self.children, 1, -1 do
        local child = self.children[i]
        if child.touchMoved and child:touchMoved(id, x, y, dx, dy, pressure) then
            return true
        end
    end
    return false
end

return ContainerElement
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/ContainerElement.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====

local class = require("lib.middleclass")

local Element = class("Element")



function Element:initialize(x, y, w, h)
    self.x, self.y = x or 0, y or 0
    self.width, self.height = w or 0, h or 0
    self.visible = true
    self.parent = nil
    self.children = {}
    self._listeners = {}
end

-- Добавление события
function Element:on(eventName, callback)
    self._listeners[eventName] = self._listeners[eventName] or {}
    table.insert(self._listeners[eventName], callback)
end

-- Удаление события
function Element:off(eventName, callback)
    local list = self._listeners[eventName]
    if not list then return end
    for i = #list, 1, -1 do
        if list[i] == callback then
            table.remove(list, i)
        end
    end
end

-- Вызов события
function Element:trigger(eventName, ...)
    local list = self._listeners[eventName]
    if not list then return end
    for _, callback in ipairs(list) do
        callback(...)
    end
end

-- Базовая реализация: переопределяется в потомках
function Element:handleEvent(eventName, ...)
    if self[eventName] then
        return self[eventName](self, ...)
    end
end

-- Вспомогательные функции
function Element:isInside(x, y)
    return x >= self.x and y >= self.y and x <= self.x + self.width and y <= self.y + self.height
end

function Element:addChild(child)
    child.parent = self
    table.insert(self.children, child)
end


function Element:removeChild(child)
    for i, c in ipairs(self.children) do
        if c == child then
            table.remove(self.children, i)
            c.parent = nil
            break
        end
    end
end

function Element:clearChildren()
    for _, c in ipairs(self.children) do
        c.parent = nil
    end
    self.children = {}
end

-- Отрисовка (рекурсивно)
function Element:draw()
    if not self.visible then return end
    if self.onDraw then self:onDraw() end
    for _, child in ipairs(self.children) do
        child:draw()
    end
end

-- Обновление (рекурсивно)
function Element:update(dt)
    if not self.enabled then return end
    if self.onUpdate then self:onUpdate(dt) end
    for _, child in ipairs(self.children) do
        child:update(dt)
    end
end

-- Обработка событий
function Element:emit(eventName, ...)
    local handler = self["on" .. eventName]
    if handler then
        local handled = handler(self, ...)
        if handled then return true end
    end

    if self.parent then
        if self.parent.emit then
            return self.parent:emit(eventName, ...)
        elseif self.parent.dispatch then
            return self.parent:dispatch(eventName, ...)
        end
    end

    return false
end

function Element:trigger(eventName, ...)
    if not self._listeners or not self._listeners[eventName] then return end
    for _, callback in ipairs(self._listeners[eventName]) do
        callback(...)
    end
end

function Element:onFocus() end
function Element:onBlur() end
function Element:focus()
    if self.parent and self.parent.setFocus then
        self.parent:setFocus(self)
    end
end

-- В классе Element
function Element:show()
    self.visible = true
end

function Element:hide()
    self.visible = false
end

function Element:isVisible()
    return self.visible
end

function Element:clearEventListeners()
    self.eventListeners = {}
end

function Element:updateLayout()
    -- Простейший пример: если в родителе есть автолейаут, перерассчитываем позицию.
    if self.parent and self.parent.updateLayout then
        self.parent:updateLayout()
    end
end

function Element:touchPressed(id, x, y, dx, dy, pressure)
    if self:isInside(x, y) then
        if self.onTouchPressed then
            self:onTouchPressed(id, x, y, dx, dy, pressure)
        end
        self:trigger("touchPressed", id, x, y, dx, dy, pressure)
        return true
    end
    return false
end

function Element:touchReleased(id, x, y, dx, dy, pressure)
    if self:isInside(x, y) then
        if self.onTouchReleased then
            self:onTouchReleased(id, x, y, dx, dy, pressure)
        end
        self:trigger("touchReleased", id, x, y, dx, dy, pressure)
        return true
    end
    return false
end

function Element:touchMoved(id, x, y, dx, dy, pressure)
    if self:isInside(x, y) then
        if self.onTouchMoved then
            self:onTouchMoved(id, x, y, dx, dy, pressure)
        end
        self:trigger("touchMoved", id, x, y, dx, dy, pressure)
        return true
    end
    return false
end

return Element
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Element.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/LayeredManager.lua ====

local middleclass = require("lib.middleclass")

local LayeredManager = middleclass("LayeredManager")

function LayeredManager:initialize()
    self.layers = {
        background = {},
        default = {},
        popups = {},
        overlay = {},
    }
    self.layerOrder = { "background", "default", "popups", "overlay" }
    self.zIndex = {}
end

function LayeredManager:addElementToLayer(element, layer)
    if self.layers[layer] then
        table.insert(self.layers[layer], element)
    end
end

function LayeredManager:bringToFront(element)
    for layer, elements in pairs(self.layers) do
        for i, el in ipairs(elements) do
            if el == element then
                table.remove(elements, i)
                table.insert(self.layers[layer], element)
                return
            end
        end
    end
end

function LayeredManager:setZIndex(element, zIndex)
    self.zIndex[element] = zIndex
end

function LayeredManager:getSortedElements()
    local sorted = {}
    for _, layer in ipairs(self.layerOrder) do
        local elements = self.layers[layer]
        for _, el in ipairs(elements) do
            table.insert(sorted, el)
        end
    end
    table.sort(sorted, function(a, b)
        return (self.zIndex[a] or 0) < (self.zIndex[b] or 0)
    end)
    return sorted
end

function LayeredManager:update(dt)
    for _, el in ipairs(self:getSortedElements()) do
        if el.update then el:update(dt) end
    end
end

function LayeredManager:draw()
    for _, el in ipairs(self:getSortedElements()) do
        if el.visible ~= false and el.draw then
            el:draw()
        end
    end
end

function LayeredManager:handleTouchPressed(id, x, y, dx, dy, pressure)
    for i = #self.layerOrder, 1, -1 do -- от верхнего слоя к нижнему
        local elements = self.layers[self.layerOrder[i]]
        for j = #elements, 1, -1 do
            local el = elements[j]
            if el.touchPressed and el:touchPressed(id, x, y, dx, dy, pressure) then
                return true -- остановить дальше
            end
        end
    end
end

function LayeredManager:handleTouchReleased(id, x, y, dx, dy, pressure)
    for i = #self.layerOrder, 1, -1 do
        local elements = self.layers[self.layerOrder[i]]
        for j = #elements, 1, -1 do
            local el = elements[j]
            if el.touchReleased and el:touchReleased(id, x, y, dx, dy, pressure) then
                return true
            end
        end
    end
end

function LayeredManager:handleTouchMoved(id, x, y, dx, dy, pressure)
    for i = #self.layerOrder, 1, -1 do
        local elements = self.layers[self.layerOrder[i]]
        for j = #elements, 1, -1 do
            local el = elements[j]
            if el.touchMoved and el:touchMoved(id, x, y, dx, dy, pressure) then
                return true
            end
        end
    end
end

return LayeredManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/LayeredManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Root.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local Root = class("Root", Element)

function Root:initialize(width, height)
    Element.initialize(self, 0, 0, width, height)
    self.focusedElement = nil
    self._layers = {
        background = {},
        default = {},
        popup = {},
        overlay = {}
    }
end

function Root:addToLayer(element, layer)
    local target = self._layers[layer] or self._layers.default
    table.insert(target, element)
    element.parent = self
end

function Root:removeElement(element)
    if self.focusedElement == element then
        self:clearFocus()
    end

    for _, layer in pairs(self._layers) do
        for i, e in ipairs(layer) do
            if e == element then
                table.remove(layer, i)
                e.parent = nil
                return
            end
        end
    end
end

function Root:draw()
    for _, layer in pairs(self._layers) do
        for _, element in ipairs(layer) do
            if element.visible and element.draw then
                element:draw()
            end
        end
    end
end

function Root:update(dt)
    for _, layer in pairs(self._layers) do
        for _, element in ipairs(layer) do
            if element.visible and element.update then
                element:update(dt)
            end
        end
    end
end

function Root:dispatch(eventName, ...)
    for _, layer in pairs(self._layers) do
        for i = #layer, 1, -1 do
            local element = layer[i]
            if element.visible and element.handleEvent and element:handleEvent(eventName, ...) then
                return true
            end
        end
    end
    return false
end

function Root:setFocus(element)
    if self.focusedElement == element then return end
    if self.focusedElement and self.focusedElement.onBlur then
        self.focusedElement:onBlur()
        self.focusedElement.hasFocus = false
    end
    self.focusedElement = element
    if element and element.onFocus then
        element:onFocus()
        element.hasFocus = true
    end
end

function Root:clearFocus()
    self:setFocus(nil)
end

function Root:getFocus()
    return self.focusedElement
end


function Root:textinput(text)
    if self.focusedElement and self.focusedElement.textinput then
        self.focusedElement:textinput(text)
    end
end

function Root:keypressed(key, scancode, isrepeat)
    if self.focusedElement and self.focusedElement.keypressed then
        self.focusedElement:keypressed(key, scancode, isrepeat)
    end
end

function Root:keyreleased(key, scancode)
    if self.focusedElement and self.focusedElement.keyreleased then
        self.focusedElement:keyreleased(key, scancode)
    end
end

return Root
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/Root.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIEventDispatcher.lua ====

local class = require("lib.middleclass")

local UIEventDispatcher = class("UIEventDispatcher")

function UIEventDispatcher:initialize()
    self._listeners = {}
end

-- Добавление слушателя события
function UIEventDispatcher:addEventListener(eventType, callback, context)
    self._listeners[eventType] = self._listeners[eventType] or {}
    table.insert(self._listeners[eventType], {callback = callback, context = context})
    return callback -- возвращаем для возможности удаления
end

-- Удаление слушателя события
function UIEventDispatcher:removeEventListener(eventType, callback)
    local listeners = self._listeners[eventType]
    if not listeners then return false end
    
    for i = #listeners, 1, -1 do
        if listeners[i].callback == callback then
            table.remove(listeners, i)
            return true
        end
    end
    
    return false
end

-- Удаление всех слушателей конкретного события
function UIEventDispatcher:removeEventListeners(eventType)
    if eventType then
        self._listeners[eventType] = nil
    else
        self._listeners = {}
    end
end

-- Проверка наличия слушателей для события
function UIEventDispatcher:hasEventListener(eventType)
    return self._listeners[eventType] ~= nil and #self._listeners[eventType] > 0
end

-- Вызов события
function UIEventDispatcher:dispatchEvent(eventType, ...)
    local listeners = self._listeners[eventType]
    if not listeners then return false end
    
    local result = false
    for _, listener in ipairs(listeners) do
        if listener.context then
            listener.callback(listener.context, ...)
        else
            listener.callback(...)
        end
        result = true
    end
    
    return result
end

-- Создание смешанного класса, добавляющего функциональность событий
function UIEventDispatcher:mixin(targetClass)
    for k, v in pairs(UIEventDispatcher.class.__instanceDict) do
        if k ~= "initialize" and k ~= "class" and k ~= "__mixins" then
            targetClass.__instanceDict[k] = v
        end
    end
    
    -- Расширяем initialize для наследников
    local originalInitialize = targetClass.initialize
    targetClass.initialize = function(self, ...)
        if originalInitialize then
            originalInitialize(self, ...)
        end
        self._listeners = {}
    end
end

return UIEventDispatcher
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIEventDispatcher.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====

local class = require("lib.middleclass")
local Root = require("src.ui.core.Root")
local LayeredManager = require("src.ui.core.LayeredManager")

local UIManager = class("UIManager")
UIManager.isInit = false
-- Синглтон для удобного доступа
local instance = nil

function UIManager.getInstance()
    if not instance then
        instance = UIManager()
    end
    
    
    return instance
end

function UIManager:initialize()
    UIManager.isInit = true
    self.root = nil
    self.layeredManager = nil
    self.width = 0
    self.height = 0
    self.scale = 1
    self.screens = {}
    self.currentScreen = nil
    self.touchHandlers = {}
    self.keyboardHandlers = {}
    self.mouseHandlers = {}
end

-- Инициализация с размерами экрана
function UIManager:init(width, height)
  
    
    self.width = width or love.graphics.getWidth()
    self.height = height or love.graphics.getHeight()
    
    self.root = Root(self.width, self.height)
    self.layeredManager = LayeredManager()
    
function love.load()
    local ui = UIManager.getInstance()
    ui:init(800, 600)
    
    -- Просто создаем кнопку без сложной иерархии
    local testButton = UIButton(100, 100, 200, 50, "Test Button", {
        backgroundColor = {1, 0, 0, 1}
    })
    
    -- Добавляем прямо в root
    ui.root:addChild(testButton)
    
    print("Button added directly to root")
end

function love.draw()
    love.graphics.clear(0.1, 0.1, 0.2)
    UIManager.getInstance():draw()
end
    
    -- Обработчики событий LÖVE
    love.touchpressed = function(id, x, y, dx, dy, pressure)
        self:handleTouchPressed(id, x, y, dx, dy, pressure)
    end
    
    love.touchreleased = function(id, x, y, dx, dy, pressure)
        self:handleTouchReleased(id, x, y, dx, dy, pressure)
    end
    
    love.touchmoved = function(id, x, y, dx, dy, pressure)
        self:handleTouchMoved(id, x, y, dx, dy, pressure)
    end
    
    love.keypressed = function(key, scancode, isrepeat)
        self:handleKeyPressed(key, scancode, isrepeat)
    end
    
    love.keyreleased = function(key, scancode)
        self:handleKeyReleased(key, scancode)
    end
    
    love.textinput = function(text)
        self:handleTextInput(text)
    end
end

-- Обработка событий касания
function UIManager:handleTouchPressed(id, x, y, dx, dy, pressure)
    local handled = false
    
    -- Сначала проверяем LayeredManager
    if self.layeredManager then
        handled = self.layeredManager:handleTouchPressed(id, x, y, dx, dy, pressure)
    end
    
    -- Если не обработано, проверяем Root
    if not handled and self.root then
        handled = self.root:dispatch("touchPressed", id, x, y, dx, dy, pressure)
    end
    
    -- Если не обработано, проверяем текущий экран
    if not handled and self.currentScreen then
        if self.currentScreen.touchPressed then
            handled = self.currentScreen:touchPressed(id, x, y, dx, dy, pressure)
        end
    end
    
    -- Дополнительные обработчики
    for _, handler in ipairs(self.touchHandlers) do
        if handler.onTouchPressed then
            handler:onTouchPressed(id, x, y, dx, dy, pressure)
        end
    end
    
    return handled
end

function UIManager:handleTouchReleased(id, x, y, dx, dy, pressure)
    local handled = false
    
    if self.layeredManager then
        handled = self.layeredManager:handleTouchReleased(id, x, y, dx, dy, pressure)
    end
    
    if not handled and self.root then
        handled = self.root:dispatch("touchReleased", id, x, y, dx, dy, pressure)
    end
    
    if not handled and self.currentScreen then
        if self.currentScreen.touchReleased then
            handled = self.currentScreen:touchReleased(id, x, y, dx, dy, pressure)
        end
    end
    
    for _, handler in ipairs(self.touchHandlers) do
        if handler.onTouchReleased then
            handler:onTouchReleased(id, x, y, dx, dy, pressure)
        end
    end
    
    return handled
end

function UIManager:handleTouchMoved(id, x, y, dx, dy, pressure)
    local handled = false
    
    if self.layeredManager then
        handled = self.layeredManager:handleTouchMoved(id, x, y, dx, dy, pressure)
    end
    
    if not handled and self.root then
        handled = self.root:dispatch("touchMoved", id, x, y, dx, dy, pressure)
    end
    
    if not handled and self.currentScreen then
        if self.currentScreen.touchMoved then
            handled = self.currentScreen:touchMoved(id, x, y, dx, dy, pressure)
        end
    end
    
    for _, handler in ipairs(self.touchHandlers) do
        if handler.onTouchMoved then
            handler:onTouchMoved(id, x, y, dx, dy, pressure)
        end
    end
    
    return handled
end

-- Обработка ввода с клавиатуры
function UIManager:handleKeyPressed(key, scancode, isrepeat)
    local handled = false
    
    if self.root then
        if self.root.keypressed then
            handled = self.root:keypressed(key, scancode, isrepeat)
        end
    end
    
    if not handled and self.currentScreen then
        if self.currentScreen.keypressed then
            handled = self.currentScreen:keypressed(key, scancode, isrepeat)
        end
    end
    
    for _, handler in ipairs(self.keyboardHandlers) do
        if handler.onKeyPressed then
            handler:onKeyPressed(key, scancode, isrepeat)
        end
    end
    
    return handled
end

function UIManager:handleKeyReleased(key, scancode)
    local handled = false
    
    if self.root then
        if self.root.keyreleased then
            handled = self.root:keyreleased(key, scancode)
        end
    end
    
    if not handled and self.currentScreen then
        if self.currentScreen.keyreleased then
            handled = self.currentScreen:keyreleased(key, scancode)
        end
    end
    
    for _, handler in ipairs(self.keyboardHandlers) do
        if handler.onKeyReleased then
            handler:onKeyReleased(key, scancode)
        end
    end
    
    return handled
end

function UIManager:handleTextInput(text)
    local handled = false
    
    if self.root then
        if self.root.textinput then
            handled = self.root:textinput(text)
        end
    end
    
    if not handled and self.currentScreen then
        if self.currentScreen.textinput then
            handled = self.currentScreen:textinput(text)
        end
    end
    
    for _, handler in ipairs(self.keyboardHandlers) do
        if handler.onTextInput then
            handler:onTextInput(text)
        end
    end
    
    return handled
end

-- Управление экранами
function UIManager:addScreen(name, screen)
    self.screens[name] = screen
end

function UIManager:removeScreen(name)
    self.screens[name] = nil
    if self.currentScreen == name then
        self.currentScreen = nil
    end
end

function UIManager:setCurrentScreen(name)
    if self.screens[name] then
        self.currentScreen = self.screens[name]
        -- Очищаем предыдущий root и добавляем новый экран
        if self.root then
            self.root:clearChildren()
            self.root:addChild(self.currentScreen)
        end
    end
end

function UIManager:getCurrentScreen()
    return self.currentScreen
end

-- Управление обработчиками событий
function UIManager:addTouchHandler(handler)
    table.insert(self.touchHandlers, handler)
end

function UIManager:removeTouchHandler(handler)
    for i, h in ipairs(self.touchHandlers) do
        if h == handler then
            table.remove(self.touchHandlers, i)
            break
        end
    end
end

function UIManager:addKeyboardHandler(handler)
    table.insert(self.keyboardHandlers, handler)
end

function UIManager:removeKeyboardHandler(handler)
    for i, h in ipairs(self.keyboardHandlers) do
        if h == handler then
            table.remove(self.keyboardHandlers, i)
            break
        end
    end
end

-- Основные методы обновления и отрисовки
function UIManager:update(dt)
    if self.layeredManager then
        self.layeredManager:update(dt)
    end
    
    if self.root then
        self.root:update(dt)
    end
    
    if self.currentScreen and self.currentScreen.update then
        self.currentScreen:update(dt)
    end
end

function UIManager:draw()
  
    local isLayered, isRoot = false, false
    if self.layeredManager then
        self.layeredManager:draw()
    end
    
    if self.root then
        self.root:draw()
    end
    
    
    function love.load()
    local ui = UIManager.getInstance()
    ui:init(800, 600)
    
    -- Просто создаем кнопку без сложной иерархии
    local testButton = UIButton(100, 100, 200, 50, "Test Button", {
        backgroundColor = {1, 0, 0, 1}
    })
    
    -- Добавляем прямо в root
    ui.root:addChild(testButton)
    
    print("Button added directly to root")
end

function love.draw()
    love.graphics.clear(0.1, 0.1, 0.2)
    UIManager.getInstance():draw()
end
    
    
end

-- Обработка изменения размера окна
function UIManager:resize(width, height)
    self.width = width
    self.height = height
    
    if self.root then
        self.root.width = width
        self.root.height = height
    end
    
    if self.currentScreen and self.currentScreen.resize then
        self.currentScreen:resize(width, height)
    end
end

return UIManager
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIManager.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIPool.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/core/UIPool.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIButton.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UIButton = class("UIButton", Element)

function UIButton:initialize(x, y, width, height, label, options)
    Element.initialize(self, x, y, width, height)
    
    self.label = label or "Button"
    self.options = options or {}
    
    -- Внешний вид
    self.backgroundColor = self.options.backgroundColor or {0.2, 0.4, 0.8, 1}
    self.textColor = self.options.textColor or {1, 1, 1, 1}
    self.font = self.options.font or love.graphics.getFont()
    self.borderRadius = self.options.borderRadius or 4
    self.padding = self.options.padding or 8
    
    -- Состояния
    self.pressed = false
    self.hovered = false
    self.enabled = true
    
    -- Коллбэки
    self.onClick = self.options.onClick
end

function UIButton:onTouchPressed(id, x, y, dx, dy, pressure)
    if not self.enabled then return false end
    self.pressed = true
    return true -- Обработано
end

function UIButton:onTouchReleased(id, x, y, dx, dy, pressure)
    if not self.enabled or not self.pressed then return false end
    
    self.pressed = false
    
    -- Если отпускание произошло внутри кнопки
    if self:isInside(x, y) and self.onClick then
        self.onClick(self)
    end
    
    return true -- Обработано
end

function UIButton:onTouchMoved(id, x, y, dx, dy, pressure)
    if not self.enabled or not self.pressed then return false end
    
    -- Обновляем состояние наведения
    self.hovered = self:isInside(x, y)
    
    return true -- Обработано
end

function UIButton:setLabel(label)
    self.label = label
end

function UIButton:setEnabled(enabled)
    self.enabled = enabled
end

function UIButton:draw()
    if not self.visible then return end
    
    -- Сохраняем текущий цвет
    local r, g, b, a = love.graphics.getColor()
    
    -- Определяем цвет кнопки на основе состояния
    local bgColor = {unpack(self.backgroundColor)}
    
    if not self.enabled then
        -- Делаем цвет более серым для отключенного состояния
        bgColor[1] = bgColor[1] * 0.7
        bgColor[2] = bgColor[2] * 0.7
        bgColor[3] = bgColor[3] * 0.7
        bgColor[4] = bgColor[4] * 0.7
    elseif self.pressed then
        -- Затемняем для нажатого состояния
        bgColor[1] = bgColor[1] * 0.8
        bgColor[2] = bgColor[2] * 0.8
        bgColor[3] = bgColor[3] * 0.8
    elseif self.hovered then
        -- Делаем ярче для наведения
        bgColor[1] = math.min(bgColor[1] * 1.2, 1)
        bgColor[2] = math.min(bgColor[2] * 1.2, 1)
        bgColor[3] = math.min(bgColor[3] * 1.2, 1)
    end
    
    -- Рисуем фон кнопки
    love.graphics.setColor(unpack(bgColor))
    
    -- Если LÖVE поддерживает скругленные прямоугольники
    if love.graphics.newCanvas then -- Проверка поддержки новой функциональности
        if self.borderRadius > 0 then
            love.graphics.rectangle("fill", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
        else
            love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
        end
    else
        -- Запасной вариант для старых версий
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Рисуем текст по центру
    love.graphics.setColor(unpack(self.textColor))
    love.graphics.setFont(self.font)
    
    local textWidth = self.font:getWidth(self.label)
    local textHeight = self.font:getHeight()
    local textX = self.x + (self.width - textWidth) / 2
    local textY = self.y + (self.height - textHeight) / 2
    
    love.graphics.print(self.label, textX, textY)
    
    -- Восстанавливаем старый цвет
    love.graphics.setColor(r, g, b, a)
    
    -- Рисуем дочерние элементы (если есть)
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

return UIButton
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIButton.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UIInputField = class("UIInputField", Element)

function UIInputField:initialize(x, y, width, height, options)
    Element.initialize(self, x, y, width, height)
    
    options = options or {}
    
    -- Свойства текста
    self.text = options.text or ""
    self.placeholder = options.placeholder or ""
    self.font = options.font or love.graphics.getFont()
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.placeholderColor = options.placeholderColor or {0.7, 0.7, 0.7, 1}
    
    -- Внешний вид
    self.backgroundColor = options.backgroundColor or {0.2, 0.2, 0.2, 1}
    self.borderColor = options.borderColor or {0.5, 0.5, 0.5, 1}
    self.focusBorderColor = options.focusBorderColor or {0.7, 0.7, 1, 1}
    self.borderWidth = options.borderWidth or 1
    self.borderRadius = options.borderRadius or 2
    self.padding = options.padding or 5
    
    -- Состояние
    self.hasFocus = false
    self.cursorPos = #self.text
    self.cursorVisible = true
    self.cursorBlinkTime = 0.5
    self.cursorTimer = 0
    self.passwordMode = options.passwordMode or false
    self.maxLength = options.maxLength or -1
    
    -- Фильтрация ввода
    self.inputFilter = options.inputFilter -- функция для фильтрации символов
    
    -- Callback
    self.onTextChanged = options.onTextChanged
    self.onEnterPressed = options.onEnterPressed
end

function UIInputField:getText()
    return self.text
end

function UIInputField:setText(text)
    self.text = text or ""
    self.cursorPos = math.min(self.cursorPos, #self.text)
    
    if self.onTextChanged then
        self.onTextChanged(self, self.text)
    end
end

function UIInputField:setPlaceholder(placeholder)
    self.placeholder = placeholder or ""
end

function UIInputField:onFocus()
    self.hasFocus = true
    self.cursorTimer = 0
    self.cursorVisible = true
end

function UIInputField:onBlur()
    self.hasFocus = false
end

-- Обработка текстового ввода
function UIInputField:textinput(text)
    if not self.hasFocus then return end
    
    -- Применяем фильтр ввода при необходимости
    if self.inputFilter and not self.inputFilter(text) then
        return
    end
    
    -- Проверяем макс. длину
    if self.maxLength > 0 and #self.text >= self.maxLength then
        return
    end
    
    -- Добавляем текст в текущую позицию курсора
    local newText = string.sub(self.text, 1, self.cursorPos) .. text .. string.sub(self.text, self.cursorPos + 1)
    self:setText(newText)
    self.cursorPos = self.cursorPos + #text
end

-- Обработка нажатия клавиш
function UIInputField:keypressed(key, scancode, isrepeat)
    if not self.hasFocus then return end
    
    if key == "backspace" then
        if self.cursorPos > 0 then
            local newText = string.sub(self.text, 1, self.cursorPos - 1) .. string.sub(self.text, self.cursorPos + 1)
            self:setText(newText)
            self.cursorPos = self.cursorPos - 1
        end
    elseif key == "delete" then
        if self.cursorPos < #self.text then
            local newText = string.sub(self.text, 1, self.cursorPos) .. string.sub(self.text, self.cursorPos + 2)
            self:setText(newText)
        end
    elseif key == "left" then
        self.cursorPos = math.max(0, self.cursorPos - 1)
    elseif key == "right" then
        self.cursorPos = math.min(#self.text, self.cursorPos + 1)
    elseif key == "home" then
        self.cursorPos = 0
    elseif key == "end" then
        self.cursorPos = #self.text
    elseif key == "return" or key == "kpenter" then
        if self.onEnterPressed then
            self.onEnterPressed(self, self.text)
        end
    end
    
    -- Сбрасываем таймер моргания курсора
    self.cursorTimer = 0
    self.cursorVisible = true
end

function UIInputField:onTouchPressed(id, x, y, dx, dy, pressure)
    if self:isInside(x, y) then
        self:focus()
        
        -- Установка позиции курсора по клику
        local clickX = x - self.x - self.padding
        local currentPos = 0
        local bestDist = math.huge
        
        for i = 0, #self.text do
            local textPart = self.passwordMode and string.rep("*", i) or string.sub(self.text, 1, i)
            local width = self.font:getWidth(textPart)
            local dist = math.abs(width - clickX)
            
            if dist < bestDist then
                bestDist = dist
                currentPos = i
            end
        end
        
        self.cursorPos = currentPos
        return true
    else
        if self.hasFocus then
            self:blur()
        end
        return false
    end
end

function UIInputField:update(dt)
    Element.update(self, dt)
    
    -- Обновление курсора
    if self.hasFocus then
        self.cursorTimer = self.cursorTimer + dt
        if self.cursorTimer >= self.cursorBlinkTime then
            self.cursorTimer = self.cursorTimer - self.cursorBlinkTime
            self.cursorVisible = not self.cursorVisible
        end
    end
end

function UIInputField:draw()
    if not self.visible then return end
    
    -- Сохраняем текущие настройки графики
    local r, g, b, a = love.graphics.getColor()
    local currentFont = love.graphics.getFont()
    
    -- Рисуем фон
    love.graphics.setColor(unpack(self.backgroundColor))
    
    if self.borderRadius > 0 and love.graphics.newCanvas then
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
    else
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Рисуем границу
    local borderColor = self.hasFocus and self.focusBorderColor or self.borderColor
    love.graphics.setColor(unpack(borderColor))
    
    if self.borderRadius > 0 and love.graphics.newCanvas then
        love.graphics.rectangle("line", self.x, self.y, self.width, self.height, self.borderRadius, self.borderRadius)
    else
        love.graphics.rectangle("line", self.x, self.y, self.width, self.height)
    end
    
    -- Устанавливаем шрифт
    love.graphics.setFont(self.font)
    
    -- Определяем, какой текст отображать
    local displayText = self.text
    if self.passwordMode then
        displayText = string.rep("*", #self.text)
    end
    
    -- Вычисляем область отображения текста
    local textX = self.x + self.padding
    local textY = self.y + (self.height - self.font:getHeight()) / 2
    
    -- Рисуем текст или плейсхолдер
    if #self.text > 0 then
        love.graphics.setColor(unpack(self.textColor))
        love.graphics.print(displayText, textX, textY)
    else
        love.graphics.setColor(unpack(self.placeholderColor))
        love.graphics.print(self.placeholder, textX, textY)
    end
    
    -- Рисуем курсор, если поле в фокусе
    if self.hasFocus and self.cursorVisible then
        local cursorX = textX
        if #self.text > 0 and self.cursorPos > 0 then
            local textBeforeCursor = self.passwordMode and string.rep("*", self.cursorPos) or string.sub(self.text, 1, self.cursorPos)
            cursorX = textX + self.font:getWidth(textBeforeCursor)
        end
        
        love.graphics.setColor(unpack(self.textColor))
        love.graphics.rectangle("fill", cursorX, textY, 1, self.font:getHeight())
    end
    
    -- Восстанавливаем настройки графики
    love.graphics.setColor(r, g, b, a)
    love.graphics.setFont(currentFont)
    
    -- Рисуем дочерние элементы
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

function UIInputField:focus()
    Element.focus(self)
end

function UIInputField:blur()
    if self.parent and self.parent.clearFocus then
        self.parent:clearFocus()
    end
end

return UIInputField
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UIInputField.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UILabel.lua ====

local class = require("lib.middleclass")
local Element = require("src.ui.core.Element")

local UILabel = class("UILabel", Element)

function UILabel:initialize(x, y, text, options)
    options = options or {}
    local width = options.width or 100
    local height = options.height or 30
    
    Element.initialize(self, x, y, width, height)
    
    -- Свойства
    self.text = text or ""
    self.options = options
    self.font = options.font or love.graphics.getFont()
    self.textColor = options.textColor or {1, 1, 1, 1}
    self.backgroundColor = options.backgroundColor or {0, 0, 0, 0} -- Прозрачный по умолчанию
    self.textAlign = options.textAlign or "left" -- left, center, right
    self.verticalAlign = options.verticalAlign or "middle" -- top, middle, bottom
    self.padding = options.padding or {left = 5, top = 5, right = 5, bottom = 5}
    
    -- Если ширина не задана явно, устанавливаем по размеру текста
    if not options.width then
        self:updateDimensions()
    end
end

function UILabel:setText(text)
    self.text = text
    if not self.options.width then
        self:updateDimensions()
    end
end

function UILabel:setFont(font)
    self.font = font
    if not self.options.width then
        self:updateDimensions()
    end
end

function UILabel:updateDimensions()
    if self.font then
        self.width = self.font:getWidth(self.text) + self.padding.left + self.padding.right
        self.height = self.font:getHeight() + self.padding.top + self.padding.bottom
    end
end

function UILabel:draw()
    if not self.visible then return end
    
    -- Сохраняем текущие настройки графики
    local r, g, b, a = love.graphics.getColor()
    local currentFont = love.graphics.getFont()
    
    -- Рисуем фон, если он не полностью прозрачный
    if self.backgroundColor[4] > 0 then
        love.graphics.setColor(unpack(self.backgroundColor))
        love.graphics.rectangle("fill", self.x, self.y, self.width, self.height)
    end
    
    -- Устанавливаем шрифт и цвет текста
    love.graphics.setFont(self.font)
    love.graphics.setColor(unpack(self.textColor))
    
    -- Вычисляем X-координату текста на основе выравнивания
    local textX = self.x + self.padding.left
    local textWidth = self.font:getWidth(self.text)
    
    if self.textAlign == "center" then
        textX = self.x + (self.width - textWidth) / 2
    elseif self.textAlign == "right" then
        textX = self.x + self.width - textWidth - self.padding.right
    end
    
    -- Вычисляем Y-координату текста на основе вертикального выравнивания
    local textY = self.y + self.padding.top
    local textHeight = self.font:getHeight()
    
    if self.verticalAlign == "middle" then
        textY = self.y + (self.height - textHeight) / 2
    elseif self.verticalAlign == "bottom" then
        textY = self.y + self.height - textHeight - self.padding.bottom
    end
    
    -- Рисуем текст
    love.graphics.print(self.text, textX, textY)
    
    -- Восстанавливаем настройки графики
    love.graphics.setColor(r, g, b, a)
    love.graphics.setFont(currentFont)
    
    -- Рисуем дочерние элементы (если есть)
    for _, child in ipairs(self.children) do
        if child.draw then
            child:draw()
        end
    end
end

return UILabel
-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/elements/UILabel.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/BlueprintBuilder.lua ====



-- НАЧАЛО ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====


-- КОНЕЦ ФАЙЛА: /storage/emulated/0/lua/GUILUA/src/ui/utils/UIStyle.lua ====

